<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>非科班的科班</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="非科班的科班"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="非科班的科班"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="一个钻研技术和热爱技术分享的博主"><meta property="og:type" content="blog"><meta property="og:title" content="非科班的科班"><meta property="og:url" content="https://removeif.github.io/"><meta property="og:site_name" content="非科班的科班"><meta property="og:description" content="一个钻研技术和热爱技术分享的博主"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://pic3.zhimg.com/v2-bfd9b8d48b2d2ef0bcd80d2cc4cc6604_xl.jpg"><meta property="article:author" content="黎杜"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://pic3.zhimg.com/v2-bfd9b8d48b2d2ef0bcd80d2cc4cc6604_xl.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"非科班的科班","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"黎杜"},"description":"专注于技术钻研与分享的技术博主"}</script><link rel="icon" href="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><link rel="stylesheet" href="/live2d/waifu.css"><script type="text/javascript" async src="/live2d/autoload.js"></script><meta name="generator" content="Hexo 5.2.0"></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/logo.png" alt="非科班的科班" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a><a class="navbar-item" href="/friend">友情</a><a class="navbar-item" href="/message">留言</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/liduchang?tab=repositories"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card widget">
            <div class="card-content">
                <h3 class="menu-label">Hot Recommend</h3><span id="index_hot_div">Loading...Wait a Minute!</span>
            </div>
        </div><!--!--><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2020-10-14  <a class="commentCountImg" href="/2020/10/14/JAVA%20%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E5%AE%8C%E6%95%B4%E5%A5%97%E8%B7%AF%EF%BC%8C%E4%BB%8E%20CPU%E3%80%81%E7%A3%81%E7%9B%98%E3%80%81%E5%86%85%E5%AD%98%E3%80%81%E7%BD%91%E7%BB%9C%E3%80%81GC%20%E4%B8%80%E6%9D%A1%E9%BE%99%EF%BC%81/#comment-container"><span class="display-none-class">d41d8cd98f00b204e9800998ecf8427e</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="d41d8cd98f00b204e9800998ecf8427e">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>42 m  <i class="fas fa-pencil-alt"> </i>6.2 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/10/14/JAVA%20%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E5%AE%8C%E6%95%B4%E5%A5%97%E8%B7%AF%EF%BC%8C%E4%BB%8E%20CPU%E3%80%81%E7%A3%81%E7%9B%98%E3%80%81%E5%86%85%E5%AD%98%E3%80%81%E7%BD%91%E7%BB%9C%E3%80%81GC%20%E4%B8%80%E6%9D%A1%E9%BE%99%EF%BC%81/"> </a></h1><div class="content"><p><img src="https://img-blog.csdnimg.cn/20200913184145385.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70#pic_center"></p>
<blockquote>
<p>作者：fredal<br><a target="_blank" rel="noopener" href="https://fredal.xin/java-error-check">https://fredal.xin/java-error-check</a></p>
</blockquote>
<article class="posts-expand">
                <header class="post-header">
                    <h2 class="post-title">
                        JAVA线上故障排查全套路
                    </h2>
                    </header>
       <div class="post-body post-body--article vditor-reset">
                    <p>线上故障主要会包括cpu、磁盘、内存以及网络问题，而大多数故障可能会包含不止一个层面的问题，所以进行排查时候尽量四个方面依次排查一遍。同时例如jstack、jmap等工具也是不囿于一个方面的问题的，基本上出问题就是df、free、top 三连，然后依次jstack、jmap伺候，具体问题具体分析即可。</p>
<h1 id="toc_h1_0">CPU</h1>
<p>一般来讲我们首先会排查cpu方面的问题。cpu异常往往还是比较好定位的。原因包括业务逻辑问题(死循环)、频繁gc以及上下文切换过多。而最常见的往往是业务逻辑(或者框架逻辑)导致的，可以使用jstack来分析对应的堆栈情况。</p>
<h3 id="toc_h3_1">使用jstack分析cpu问题</h3>
<p>我们先用ps命令找到对应进程的pid(如果你有好几个目标进程，可以先用top看一下哪个占用比较高)。<br>
接着用<code>top -H -p pid</code>来找到cpu使用率比较高的一些线程<br>
<img src="https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2019-11-04-083804.png" alt=""><br>
然后将占用最高的pid转换为16进制<code>printf '%x\n' pid</code>得到nid<br>
<img src="https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2019-11-04-083806.png" alt=""><br>
接着直接在jstack中找到相应的堆栈信息<code>jstack pid |grep 'nid' -C5 –color</code><br>
<img src="https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2019-11-04-83807.png" alt=""><br>
可以看到我们已经找到了nid为0x42的堆栈信息，接着只要仔细分析一番即可。</p>
<p>当然更常见的是我们对整个jstack文件进行分析，通常我们会比较关注WAITING和TIMED_WAITING的部分，BLOCKED就不用说了。我们可以使用命令<code>cat jstack.log | grep "java.lang.Thread.State" | sort -nr | uniq -c</code>来对jstack的状态有一个整体的把握，如果WAITING之类的特别多，那么多半是有问题啦。<br>
<img src="https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2019-11-04-083807.png" alt=""></p>
<h3 id="toc_h3_2">频繁gc</h3>
<p>当然我们还是会使用jstack来分析问题，但有时候我们可以先确定下gc是不是太频繁，使用<code>jstat -gc pid 1000</code>命令来对gc分代变化情况进行观察，1000表示采样间隔(ms)，S0C/S1C、S0U/S1U、EC/EU、OC/OU、MC/MU分别代表两个Survivor区、Eden区、老年代、元数据区的容量和使用量。YGC/YGT、FGC/FGCT、GCT则代表YoungGc、FullGc的耗时和次数以及总耗时。如果看到gc比较频繁，再针对gc方面做进一步分析，具体可以参考一下gc章节的描述。<br>
<img src="https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2019-11-04-083808.png" alt=""></p>
<h3 id="toc_h3_3">上下文切换</h3>
<p>针对频繁上下文问题，我们可以使用<code>vmstat</code>命令来进行查看<br>
<img src="https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2019-11-04-083809.png" alt=""><br>
cs(context switch)一列则代表了上下文切换的次数。<br>
如果我们希望对特定的pid进行监控那么可以使用 <code>pidstat -w pid</code>命令，cswch和nvcswch表示自愿及非自愿切换。<br>
<img src="https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2019-11-04-83810.png" alt=""></p>
<h1 id="toc_h1_4">磁盘</h1>
<p>磁盘问题和cpu一样是属于比较基础的。首先是磁盘空间方面，我们直接使用<code>df -hl</code>来查看文件系统状态<br>
<img src="https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2019-11-04-083810.png" alt=""></p>
<p>更多时候，磁盘问题还是性能上的问题。我们可以通过iostat<code>iostat -d -k -x</code>来进行分析<br>
<img src="https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2019-11-04-083811.png" alt=""><br>
最后一列<code>%util</code>可以看到每块磁盘写入的程度，而<code>rrqpm/s</code>以及<code>wrqm/s</code>分别表示读写速度，一般就能帮助定位到具体哪块磁盘出现问题了。</p>
<p>另外我们还需要知道是哪个进程在进行读写，一般来说开发自己心里有数，或者用iotop命令来进行定位文件读写的来源。<br>
<img src="https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2019-11-04-083812.png" alt=""><br>
不过这边拿到的是tid，我们要转换成pid，可以通过readlink来找到pid<code>readlink -f /proc/*/task/tid/../..</code>。<br>
<img src="https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2019-11-04-83813.png" alt=""><br>
找到pid之后就可以看这个进程具体的读写情况<code>cat /proc/pid/io</code><br>
<img src="https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2019-11-04-083813.png" alt=""><br>
我们还可以通过lsof命令来确定具体的文件读写情况<code>lsof -p pid</code><br>
<img src="https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2019-11-04-083814.png" alt=""></p>
<h1 id="toc_h1_5">内存</h1>
<p>内存问题排查起来相对比CPU麻烦一些，场景也比较多。主要包括OOM、GC问题和堆外内存。一般来讲，我们会先用<code>free</code>命令先来检查一发内存的各种情况。<br>
<img src="https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2019-11-04-083815.png" alt=""></p>
<h3 id="toc_h3_6">堆内内存</h3>
<p>内存问题大多还都是堆内内存问题。表象上主要分为OOM和StackOverflow。</p>
<h4 id="toc_h4_7">OOM</h4>
<p>JMV中的内存不足，OOM大致可以分为以下几种：</p>
<p><strong>Exception in thread "main" java.lang.OutOfMemoryError: unable to create new native thread</strong><br>
这个意思是没有足够的内存空间给线程分配java栈，基本上还是线程池代码写的有问题，比如说忘记shutdown，所以说应该首先从代码层面来寻找问题，使用jstack或者jmap。如果一切都正常，JVM方面可以通过指定<code>Xss</code>来减少单个thread stack的大小。另外也可以在系统层面，可以通过修改<code>/etc/security/limits.conf</code>nofile和nproc来增大os对线程的限制<br>
<img src="https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2019-11-04-83816.png" alt=""></p>
<p><strong>Exception in thread "main" java.lang.OutOfMemoryError: Java heap space</strong><br>
这个意思是堆的内存占用已经达到-Xmx设置的最大值，应该是最常见的OOM错误了。解决思路仍然是先应该在代码中找，怀疑存在内存泄漏，通过jstack和jmap去定位问题。如果说一切都正常，才需要通过调整<code>Xmx</code>的值来扩大内存。</p>
<p><strong>Caused by: java.lang.OutOfMemoryError: Meta space</strong><br>
这个意思是元数据区的内存占用已经达到<code>XX:MaxMetaspaceSize</code>设置的最大值，排查思路和上面的一致，参数方面可以通过<code>XX:MaxPermSize</code>来进行调整(这里就不说1.8以前的永久代了)。</p>
<h4 id="toc_h4_8">Stack Overflow</h4>
<p>栈内存溢出，这个大家见到也比较多。<br>
<strong>Exception in thread "main" java.lang.StackOverflowError</strong><br>
表示线程栈需要的内存大于Xss值，同样也是先进行排查，参数方面通过<code>Xss</code>来调整，但调整的太大可能又会引起OOM。</p>
<h4 id="toc_h4_9">使用JMAP定位代码内存泄漏</h4>
<p>上述关于OOM和StackOverflow的代码排查方面，我们一般使用JMAP<code>jmap -dump:format=b,file=filename pid</code>来导出dump文件<br>
<img src="https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2019-11-04-083817.png" alt=""><br>
通过mat(Eclipse Memory Analysis Tools)导入dump文件进行分析，内存泄漏问题一般我们直接选Leak Suspects即可，mat给出了内存泄漏的建议。另外也可以选择Top Consumers来查看最大对象报告。和线程相关的问题可以选择thread overview进行分析。除此之外就是选择Histogram类概览来自己慢慢分析，大家可以搜搜mat的相关教程。<br>
<img src="https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2019-11-04-083818.png" alt=""></p>
<p>日常开发中，代码产生内存泄漏是比较常见的事，并且比较隐蔽，需要开发者更加关注细节。比如说每次请求都new对象，导致大量重复创建对象；进行文件流操作但未正确关闭；手动不当触发gc；ByteBuffer缓存分配不合理等都会造成代码OOM。</p>
<p>另一方面，我们可以在启动参数中指定<code>-XX:+HeapDumpOnOutOfMemoryError</code>来保存OOM时的dump文件。</p>
<h4 id="toc_h4_10">gc问题和线程</h4>
<p>gc问题除了影响cpu也会影响内存，排查思路也是一致的。一般先使用jstat来查看分代变化情况，比如youngGC或者fullGC次数是不是太多呀；EU、OU等指标增长是不是异常呀等。<br>
线程的话太多而且不被及时gc也会引发oom，大部分就是之前说的<code>unable to create new native thread</code>。除了jstack细细分析dump文件外，我们一般先会看下总体线程，通过<code>pstreee -p pid |wc -l</code>。<br>
<img src="https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2019-11-04-083819.png" alt=""><br>
或者直接通过查看<code>/proc/pid/task</code>的数量即为线程数量。<br>
<img src="https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2019-11-04-083820.png" alt=""></p>
<h3 id="toc_h3_11">堆外内存</h3>
<p>如果碰到堆外内存溢出，那可真是太不幸了。首先堆外内存溢出表现就是物理常驻内存增长快，报错的话视使用方式都不确定，如果由于使用Netty导致的，那错误日志里可能会出现<code>OutOfDirectMemoryError</code>错误，如果直接是DirectByteBuffer，那会报<code>OutOfMemoryError: Direct buffer memory</code>。</p>
<p>堆外内存溢出往往是和NIO的使用相关，一般我们先通过pmap来查看下进程占用的内存情况<code>pmap -x pid | sort -rn -k3 | head -30</code>，这段意思是查看对应pid倒序前30大的内存段。这边可以再一段时间后再跑一次命令看看内存增长情况，或者和正常机器比较可疑的内存段在哪里。<br>
<img src="https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2019-11-04-83821.png" alt=""><br>
我们如果确定有可疑的内存端，需要通过gdb来分析<code>gdb --batch --pid &#123;pid&#125; -ex "dump memory filename.dump &#123;内存起始地址&#125; &#123;内存起始地址+内存块大小&#125;"</code><br>
<img src="https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2019-11-04-083821.png" alt=""><br>
获取dump文件后可用heaxdump进行查看<code>hexdump -C filename | less</code>，不过大多数看到的都是二进制乱码。</p>
<p>NMT是Java7U40引入的HotSpot新特性，配合jcmd命令我们就可以看到具体内存组成了。需要在启动参数中加入 <code>-XX:NativeMemoryTracking=summary</code> 或者 <code>-XX:NativeMemoryTracking=detail</code>，会有略微性能损耗。</p>
<p>一般对于堆外内存缓慢增长直到爆炸的情况来说，可以先设一个基线<code>jcmd pid VM.native_memory baseline</code>。<br>
<img src="https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2019-11-04-083822.png" alt=""><br>
然后等放一段时间后再去看看内存增长的情况，通过<code>jcmd pid VM.native_memory detail.diff(summary.diff)</code>做一下summary或者detail级别的diff。<br>
<img src="https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2019-11-04-083823.png" alt=""><br>
<img src="https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2019-11-04-83824.png" alt=""><br>
可以看到jcmd分析出来的内存十分详细，包括堆内、线程以及gc(所以上述其他内存异常其实都可以用nmt来分析)，这边堆外内存我们重点关注Internal的内存增长，如果增长十分明显的话那就是有问题了。<br>
detail级别的话还会有具体内存段的增长情况，如下图。<br>
<img src="https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2019-11-04-083824.png" alt=""></p>
<p>此外在系统层面，我们还可以使用strace命令来监控内存分配 <code>strace -f -e "brk,mmap,munmap" -p pid</code><br>
这边内存分配信息主要包括了pid和内存地址。<br>
<img src="https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2019-11-04-083825.jpg" alt=""></p>
<p>不过其实上面那些操作也很难定位到具体的问题点，关键还是要看错误日志栈，找到可疑的对象，搞清楚它的回收机制，然后去分析对应的对象。比如DirectByteBuffer分配内存的话，是需要full GC或者手动system.gc来进行回收的(所以最好不要使用<code>-XX:+DisableExplicitGC</code>)。那么其实我们可以跟踪一下DirectByteBuffer对象的内存情况，通过<code>jmap -histo:live pid</code>手动触发fullGC来看看堆外内存有没有被回收。如果被回收了，那么大概率是堆外内存本身分配的太小了，通过<code>-XX:MaxDirectMemorySize</code>进行调整。如果没有什么变化，那就要使用jmap去分析那些不能被gc的对象，以及和DirectByteBuffer之间的引用关系了。</p>
<h1 id="toc_h1_12">GC问题</h1>
<p>堆内内存泄漏总是和GC异常相伴。不过GC问题不只是和内存问题相关，还有可能引起CPU负载、网络问题等系列并发症，只是相对来说和内存联系紧密些，所以我们在此单独总结一下GC相关问题。</p>
<p>我们在cpu章介绍了使用jstat来获取当前GC分代变化信息。而更多时候，我们是通过GC日志来排查问题的，在启动参数中加上<code>-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps</code>来开启GC日志。<br>
常见的Young GC、Full GC日志含义在此就不做赘述了。</p>
<p>针对gc日志，我们就能大致推断出youngGC与fullGC是否过于频繁或者耗时过长，从而对症下药。我们下面将对G1垃圾收集器来做分析，这边也建议大家使用G1<code>-XX:+UseG1GC</code>。</p>
<p><strong>youngGC过频繁</strong><br>
youngGC频繁一般是短周期小对象较多，先考虑是不是Eden区/新生代设置的太小了，看能否通过调整-Xmn、-XX:SurvivorRatio等参数设置来解决问题。如果参数正常，但是young gc频率还是太高，就需要使用Jmap和MAT对dump文件进行进一步排查了。</p>
<p><strong>youngGC耗时过长</strong><br>
耗时过长问题就要看GC日志里耗时耗在哪一块了。以G1日志为例，可以关注Root Scanning、Object Copy、Ref Proc等阶段。Ref Proc耗时长，就要注意引用相关的对象。Root Scanning耗时长，就要注意线程数、跨代引用。Object Copy则需要关注对象生存周期。而且耗时分析它需要横向比较，就是和其他项目或者正常时间段的耗时比较。比如说图中的Root Scanning和正常时间段比增长较多，那就是起的线程太多了。<br>
<img src="https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2019-11-04-083826.png" alt=""></p>
<p><strong>触发fullGC</strong><br>
G1中更多的还是mixedGC，但mixedGC可以和youngGC思路一样去排查。触发fullGC了一般都会有问题，G1会退化使用Serial收集器来完成垃圾的清理工作，暂停时长达到秒级别，可以说是半跪了。<br>
fullGC的原因可能包括以下这些，以及参数调整方面的一些思路：</p>
<ul>
<li>并发阶段失败：在并发标记阶段，MixGC之前老年代就被填满了，那么这时候G1就会放弃标记周期。这种情况，可能就需要增加堆大小，或者调整并发标记线程数<code>-XX:ConcGCThreads</code>。</li>
<li>晋升失败：在GC的时候没有足够的内存供存活/晋升对象使用，所以触发了Full GC。这时候可以通过<code>-XX:G1ReservePercent</code>来增加预留内存百分比，减少<code>-XX:InitiatingHeapOccupancyPercent</code>来提前启动标记，<code>-XX:ConcGCThreads</code>来增加标记线程数也是可以的。</li>
<li>大对象分配失败：大对象找不到合适的region空间进行分配，就会进行fullGC，这种情况下可以增大内存或者增大<code>-XX:G1HeapRegionSize</code>。</li>
<li>程序主动执行System.gc()：不要随便写就对了。</li>
</ul>
<p>另外，我们可以在启动参数中配置<code>-XX:HeapDumpPath=/xxx/dump.hprof</code>来dump fullGC相关的文件，并通过jinfo来进行gc前后的dump</p>
<pre><div class="vditor-copy"><textarea></textarea><span aria-label="复制" onmouseover="this.setAttribute('aria-label', '复制')" class="vditor-tooltipped vditor-tooltipped__w" onclick="this.previousElementSibling.select();document.execCommand('copy');this.setAttribute('aria-label', '已复制')"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" width="32px" height="32px"> <path d="M28.681 11.159c-0.694-0.947-1.662-2.053-2.724-3.116s-2.169-2.030-3.116-2.724c-1.612-1.182-2.393-1.319-2.841-1.319h-11.5c-1.379 0-2.5 1.121-2.5 2.5v23c0 1.378 1.121 2.5 2.5 2.5h19c1.378 0 2.5-1.122 2.5-2.5v-15.5c0-0.448-0.137-1.23-1.319-2.841zM24.543 9.457c0.959 0.959 1.712 1.825 2.268 2.543h-4.811v-4.811c0.718 0.556 1.584 1.309 2.543 2.268v0zM28 29.5c0 0.271-0.229 0.5-0.5 0.5h-19c-0.271 0-0.5-0.229-0.5-0.5v-23c0-0.271 0.229-0.5 0.5-0.5 0 0 11.499-0 11.5 0v7c0 0.552 0.448 1 1 1h7v15.5zM18.841 1.319c-1.612-1.182-2.393-1.319-2.841-1.319h-11.5c-1.378 0-2.5 1.121-2.5 2.5v23c0 1.207 0.86 2.217 2 2.45v-25.45c0-0.271 0.229-0.5 0.5-0.5h15.215c-0.301-0.248-0.595-0.477-0.873-0.681z"></path> </svg></span></div><code class="language-java hljs" style="max-height: 640px;">jinfo -flag +HeapDumpBeforeFullGC pid 
jinfo -flag +HeapDumpAfterFullGC pid
</code></pre>
<p>这样得到2份dump文件，对比后主要关注被gc掉的问题对象来定位问题。</p>
<h1 id="toc_h1_13">网络</h1>
<p>涉及到网络层面的问题一般都比较复杂，场景多，定位难，成为了大多数开发的噩梦，应该是最复杂的了。这里会举一些例子，并从tcp层、应用层以及工具的使用等方面进行阐述。</p>
<h3 id="toc_h3_14">超时</h3>
<p>超时错误大部分处在应用层面，所以这块着重理解概念。超时大体可以分为连接超时和读写超时，某些使用连接池的客户端框架还会存在获取连接超时和空闲连接清理超时。</p>
<ul>
<li>
<p>读写超时。readTimeout/writeTimeout，有些框架叫做so_timeout或者socketTimeout，均指的是数据读写超时。注意这边的超时大部分是指逻辑上的超时。soa的超时指的也是读超时。读写超时一般都只针对客户端设置。</p>
</li>
<li>
<p>连接超时。connectionTimeout，客户端通常指与服务端建立连接的最大时间。服务端这边connectionTimeout就有些五花八门了，jetty中表示空闲连接清理时间，tomcat则表示连接维持的最大时间。</p>
</li>
<li>
<p>其他。包括连接获取超时connectionAcquireTimeout和空闲连接清理超时idleConnectionTimeout。多用于使用连接池或队列的客户端或服务端框架。</p>
</li>
</ul>
<p>我们在设置各种超时时间中，需要确认的是尽量保持客户端的超时小于服务端的超时，以保证连接正常结束。</p>
<p>在实际开发中，我们关心最多的应该是接口的读写超时了。</p>
<p>如何设置合理的接口超时是一个问题。如果接口超时设置的过长，那么有可能会过多地占用服务端的tcp连接。而如果接口设置的过短，那么接口超时就会非常频繁。</p>
<p>服务端接口明明rt降低，但客户端仍然一直超时又是另一个问题。这个问题其实很简单，客户端到服务端的链路包括网络传输、排队以及服务处理等，每一个环节都可能是耗时的原因。</p>
<h3 id="toc_h3_15">TCP队列溢出</h3>
<p>tcp队列溢出是个相对底层的错误，它可能会造成超时、rst等更表层的错误。因此错误也更隐蔽，所以我们单独说一说。<br>
<img src="https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2019-11-04-083827.jpg" alt=""></p>
<p>如上图所示，这里有两个队列：syns queue(半连接队列）、accept queue（全连接队列）。三次握手，在server收到client的syn后，把消息放到syns queue，回复syn+ack给client，server收到client的ack，如果这时accept queue没满，那就从syns queue拿出暂存的信息放入accept queue中，否则按tcp_abort_on_overflow指示的执行。</p>
<p>tcp_abort_on_overflow 0表示如果三次握手第三步的时候accept queue满了那么server扔掉client发过来的ack。tcp_abort_on_overflow 1则表示第三步的时候如果全连接队列满了，server发送一个rst包给client，表示废掉这个握手过程和这个连接，意味着日志里可能会有很多<code>connection reset / connection reset by peer</code>。</p>
<p>那么在实际开发中，我们怎么能快速定位到tcp队列溢出呢？</p>
<p><strong>netstat命令，执行netstat -s | egrep "listen|LISTEN"</strong><br>
<img src="https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2019-11-04-83828.jpg" alt=""><br>
如上图所示，overflowed表示全连接队列溢出的次数，sockets dropped表示半连接队列溢出的次数。</p>
<p><strong>ss命令，执行ss -lnt</strong><br>
<img src="https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2019-11-04-083828.jpg" alt=""><br>
上面看到Send-Q 表示第三列的listen端口上的全连接队列最大为5，第一列Recv-Q为全连接队列当前使用了多少。</p>
<p>接着我们看看怎么设置全连接、半连接队列大小吧：</p>
<p>全连接队列的大小取决于min(backlog, somaxconn)。backlog是在socket创建的时候传入的，somaxconn是一个os级别的系统参数。而半连接队列的大小取决于max(64, /proc/sys/net/ipv4/tcp_max_syn_backlog)。</p>
<p>在日常开发中，我们往往使用servlet容器作为服务端，所以我们有时候也需要关注容器的连接队列大小。在tomcat中backlog叫做<code>acceptCount</code>，在jetty里面则是<code>acceptQueueSize</code>。</p>
<h3 id="toc_h3_16">RST异常</h3>
<p>RST包表示连接重置，用于关闭一些无用的连接，通常表示异常关闭，区别于四次挥手。</p>
<p>在实际开发中，我们往往会看到<code>connection reset / connection reset by peer</code>错误，这种情况就是RST包导致的。</p>
<p><strong>端口不存在</strong></p>
<p>如果像不存在的端口发出建立连接SYN请求，那么服务端发现自己并没有这个端口则会直接返回一个RST报文，用于中断连接。</p>
<p><strong>主动代替FIN终止连接</strong></p>
<p>一般来说，正常的连接关闭都是需要通过FIN报文实现，然而我们也可以用RST报文来代替FIN，表示直接终止连接。实际开发中，可设置SO_LINGER数值来控制，这种往往是故意的，来跳过TIMED_WAIT，提供交互效率，不闲就慎用。</p>
<p><strong>客户端或服务端有一边发生了异常，该方向对端发送RST以告知关闭连接</strong></p>
<p>我们上面讲的tcp队列溢出发送RST包其实也是属于这一种。这种往往是由于某些原因，一方无法再能正常处理请求连接了(比如程序崩了，队列满了)，从而告知另一方关闭连接。</p>
<p><strong>接收到的TCP报文不在已知的TCP连接内</strong></p>
<p>比如，一方机器由于网络实在太差TCP报文失踪了，另一方关闭了该连接，然后过了许久收到了之前失踪的TCP报文，但由于对应的TCP连接已不存在，那么会直接发一个RST包以便开启新的连接。</p>
<p><strong>一方长期未收到另一方的确认报文，在一定时间或重传次数后发出RST报文</strong></p>
<p>这种大多也和网络环境相关了，网络环境差可能会导致更多的RST报文。</p>
<p>之前说过RST报文多会导致程序报错，在一个已关闭的连接上读操作会报<code>connection reset</code>，而在一个已关闭的连接上写操作则会报<code>connection reset by peer</code>。通常我们可能还会看到<code>broken pipe</code>错误，这是管道层面的错误，表示对已关闭的管道进行读写，往往是在收到RST，报出<code>connection reset</code>错后继续读写数据报的错，这个在glibc源码注释中也有介绍。</p>
<p>我们在排查故障时候怎么确定有RST包的存在呢？当然是使用tcpdump命令进行抓包，并使用wireshark进行简单分析了。<code>tcpdump -i en0 tcp -w xxx.cap</code>，en0表示监听的网卡。<br>
<img src="https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2019-11-04-083829.jpg" alt=""></p>
<p>接下来我们通过wireshark打开抓到的包，可能就能看到如下图所示，红色的就表示RST包了。<br>
<img src="https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2019-11-04-083830.jpg" alt=""></p>
<h3 id="toc_h3_17">TIME_WAIT和CLOSE_WAIT</h3>
<p>TIME_WAIT和CLOSE_WAIT是啥意思相信大家都知道。<br>
在线上时，我们可以直接用命令<code>netstat -n | awk '/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;'</code>来查看time-wait和close_wait的数量</p>
<p>用ss命令会更快<code>ss -ant | awk '&#123;++S[$1]&#125; END &#123;for(a in S) print a, S[a]&#125;'</code></p>
<p><img src="https://fredal-blog.oss-cn-hangzhou.aliyuncs.com/2019-11-04-083830.png" alt=""></p>
<h4 id="toc_h4_18">TIME_WAIT</h4>
<p>time_wait的存在一是为了丢失的数据包被后面连接复用，二是为了在2MSL的时间范围内正常关闭连接。它的存在其实会大大减少RST包的出现。</p>
<p>过多的time_wait在短连接频繁的场景比较容易出现。这种情况可以在服务端做一些内核参数调优:</p>
<pre><div class="vditor-copy"><textarea></textarea><span aria-label="复制" onmouseover="this.setAttribute('aria-label', '复制')" class="vditor-tooltipped vditor-tooltipped__w" onclick="this.previousElementSibling.select();document.execCommand('copy');this.setAttribute('aria-label', '已复制')"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" width="32px" height="32px"> <path d="M28.681 11.159c-0.694-0.947-1.662-2.053-2.724-3.116s-2.169-2.030-3.116-2.724c-1.612-1.182-2.393-1.319-2.841-1.319h-11.5c-1.379 0-2.5 1.121-2.5 2.5v23c0 1.378 1.121 2.5 2.5 2.5h19c1.378 0 2.5-1.122 2.5-2.5v-15.5c0-0.448-0.137-1.23-1.319-2.841zM24.543 9.457c0.959 0.959 1.712 1.825 2.268 2.543h-4.811v-4.811c0.718 0.556 1.584 1.309 2.543 2.268v0zM28 29.5c0 0.271-0.229 0.5-0.5 0.5h-19c-0.271 0-0.5-0.229-0.5-0.5v-23c0-0.271 0.229-0.5 0.5-0.5 0 0 11.499-0 11.5 0v7c0 0.552 0.448 1 1 1h7v15.5zM18.841 1.319c-1.612-1.182-2.393-1.319-2.841-1.319h-11.5c-1.378 0-2.5 1.121-2.5 2.5v23c0 1.207 0.86 2.217 2 2.45v-25.45c0-0.271 0.229-0.5 0.5-0.5h15.215c-0.301-0.248-0.595-0.477-0.873-0.681z"></path> </svg></span></div><code class="language-java hljs" style="max-height: 640px;">#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为<span class="hljs-number">0</span>，表示关闭
net.ipv4.tcp_tw_reuse = <span class="hljs-number">1</span>
#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为<span class="hljs-number">0</span>，表示关闭
net.ipv4.tcp_tw_recycle = <span class="hljs-number">1</span>
</code></pre>
<p>当然我们不要忘记在NAT环境下因为时间戳错乱导致数据包被拒绝的坑了，另外的办法就是改小<code>tcp_max_tw_buckets</code>，超过这个数的time_wait都会被干掉，不过这也会导致报<code>time wait bucket table overflow</code>的错。</p>
<h4 id="toc_h4_19">CLOSE_WAIT</h4>
<p>close_wait往往都是因为应用程序写的有问题，没有在ACK后再次发起FIN报文。close_wait出现的概率甚至比time_wait要更高，后果也更严重。往往是由于某个地方阻塞住了，没有正常关闭连接，从而渐渐地消耗完所有的线程。</p>
<p>想要定位这类问题，最好是通过jstack来分析线程堆栈来排查问题，具体可参考上述章节。这里仅举一个例子。</p>
<p>开发同学说应用上线后CLOSE_WAIT就一直增多，直到挂掉为止，jstack后找到比较可疑的堆栈是大部分线程都卡在了<code>countdownlatch.await</code>方法，找开发同学了解后得知使用了多线程但是确没有catch异常，修改后发现异常仅仅是最简单的升级sdk后常出现的<code>class not found</code>。</p>
                        <div>
                            <hr>
                        </div>
                </div>
               </article>
![](https://img-blog.csdnimg.cn/202009131842051.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70#pic_center)

</div><div class="index-category-tag">  <hr></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2020-10-14  <a class="commentCountImg" href="/2020/10/14/%E5%9B%BE%E7%89%87%E5%AD%98%E5%82%A8%E6%96%B9%E6%A1%88%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B-%E4%B8%83%E7%89%9B%E4%BA%91%E5%AD%98%E5%82%A8/#comment-container"><span class="display-none-class">d41d8cd98f00b204e9800998ecf8427e</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="d41d8cd98f00b204e9800998ecf8427e">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>16 m  <i class="fas fa-pencil-alt"> </i>2.4 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/10/14/%E5%9B%BE%E7%89%87%E5%AD%98%E5%82%A8%E6%96%B9%E6%A1%88%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B-%E4%B8%83%E7%89%9B%E4%BA%91%E5%AD%98%E5%82%A8/"> </a></h1><div class="content"><p><img src="https://img-blog.csdnimg.cn/20200912201936610.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70#pic_center"></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在我们实际的项目中，经常会将服务器进行划分，比如：专门运行我们程序的应用服务器、专门运行我们数据库的数据库服务器、还有负责文件存储的文件服务器、负责视频存储的服务器。</p>
<p>这些服务器组成我们的所有服务、各司其职，这样划分的目的相比大家也知道，减轻一台服务器服务器的压力。</p>
<p>当用户请求我们应用应用服务器的时候，由我们的应用再分别访问我们数据库服务器、文件存储服务器等，最后将请求的资源返回给我们的用户，这样构成整个应用的请求过程：</p>
<p><img src="https://img-blog.csdnimg.cn/20200912111740125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>我们今天要讲的就是图片存储，图片储存的方案有很多，比如：可以使用<code>Fastdfs</code>或者<code>HDFS</code>、使用<code>nginx</code>搭建图片存储服务器。</p>
<p>现在比较流行的就是<strong>云存储</strong>，使用<strong>阿里云、七牛云</strong>等。这一节我们使用七牛云做了实例讲解。</p>
<h2 id="七牛云入门"><a href="#七牛云入门" class="headerlink" title="七牛云入门"></a>七牛云入门</h2><p>要是用七牛云的服务，首先注册七牛云账号：<a target="_blank" rel="noopener" href="https://www.qiniu.com/%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%98%AF%E4%B8%83%E7%89%9B%E4%BA%91%E7%9A%84%E9%A6%96%E9%A1%B5%E5%9C%B0%E5%9D%80%EF%BC%9A">https://www.qiniu.com/，这个是七牛云的首页地址：</a></p>
<p><img src="https://img-blog.csdnimg.cn/20200912171748513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70#pic_center"><br>注册完后直接登陆，登陆后右上角有一个<strong>管理控制平台</strong>，点击管理控制平台的产品首页，还要进行<strong>实名认证才能创建对象存储存储空间</strong>，实名认证后点击对象存储的<strong>立即添加</strong>：</p>
<p><img src="https://img-blog.csdnimg.cn/20200912172128117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70#pic_center"><br>点击立即添加后来到对象存储空间的创建页面，点击<strong>新建空间</strong><br><img src="https://img-blog.csdnimg.cn/20200912173431141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>创建存储空间后可以看见自己创建的空间的详细信息，并且可以创建多个存储空间，每一个存储空间相互独立，不会互相干扰。</p>
<p>七牛云提供了多种的方式操作对象存储服务，我们这里使用的是Java SDK方式，具体的使用可以在开发者中心查看：</p>
<p><img src="https://img-blog.csdnimg.cn/20200912175952904.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70#pic_center"></p>
<p><img src="https://img-blog.csdnimg.cn/20200912180046933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>在<code>Java SDK</code>开发文档里面有详细的操作的API说明，以及要引入的依赖坐标。</p>
<p><img src="https://img-blog.csdnimg.cn/20200912180339607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70#pic_center"></p>
<h2 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h2><p>首先在自己的项目中引入七牛云的依赖坐标：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.qiniu&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;qiniu-java-sdk&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;7.2.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>从Java SDK的操作文档中，简单操作文档的上传的示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;构造一个带指定 Region 对象的配置类</span><br><span class="line">Configuration cfg &#x3D; new Configuration(Region.region0());</span><br><span class="line">&#x2F;&#x2F;...其他参数参考类注释</span><br><span class="line">UploadManager uploadManager &#x3D; new UploadManager(cfg);</span><br><span class="line">&#x2F;&#x2F;...生成上传凭证，然后准备上传，填写AK和SK以及buket name</span><br><span class="line">String accessKey &#x3D; &quot;your access key&quot;;</span><br><span class="line">String secretKey &#x3D; &quot;your secret key&quot;;</span><br><span class="line">String bucket &#x3D; &quot;your bucket name&quot;;</span><br><span class="line">&#x2F;&#x2F;文件路径，如果是Windows情况下，格式是 D:\\qiniu\\test.png</span><br><span class="line">String localFilePath &#x3D; &quot;&#x2F;home&#x2F;qiniu&#x2F;test.png&quot;;</span><br><span class="line">&#x2F;&#x2F;默认不指定key的情况下，以文件内容的hash值作为文件名</span><br><span class="line">String key &#x3D; null;</span><br><span class="line">Auth auth &#x3D; Auth.create(accessKey, secretKey);</span><br><span class="line">String upToken &#x3D; auth.uploadToken(bucket);</span><br><span class="line">try &#123;</span><br><span class="line">    Response response &#x3D; uploadManager.put(localFilePath, key, upToken);</span><br><span class="line">    &#x2F;&#x2F;解析上传成功的结果</span><br><span class="line">    DefaultPutRet putRet &#x3D; new Gson().fromJson(response.bodyString(), DefaultPutRet.class);</span><br><span class="line">    System.out.println(putRet.key);</span><br><span class="line">    System.out.println(putRet.hash);</span><br><span class="line">&#125; catch (QiniuException ex) &#123;</span><br><span class="line">    Response r &#x3D; ex.response;</span><br><span class="line">    System.err.println(r.toString());</span><br><span class="line">    try &#123;</span><br><span class="line">        System.err.println(r.bodyString());</span><br><span class="line">    &#125; catch (QiniuException ex2) &#123;</span><br><span class="line">        &#x2F;&#x2F;ignore</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的是根据文件路径来上传文件，还支持字节数组上传到空间中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;构造一个带指定 Region 对象的配置类</span><br><span class="line">Configuration cfg &#x3D; new Configuration(Region.region0());</span><br><span class="line">&#x2F;&#x2F;...其他参数参考类注释</span><br><span class="line">UploadManager uploadManager &#x3D; new UploadManager(cfg);</span><br><span class="line">&#x2F;&#x2F;...生成上传凭证，然后准备上传</span><br><span class="line">String accessKey &#x3D; &quot;your access key&quot;;</span><br><span class="line">String secretKey &#x3D; &quot;your secret key&quot;;</span><br><span class="line">String bucket &#x3D; &quot;your bucket name&quot;;</span><br><span class="line">&#x2F;&#x2F;默认不指定key的情况下，以文件内容的hash值作为文件名</span><br><span class="line">String key &#x3D; null;</span><br><span class="line">try &#123;</span><br><span class="line">    byte[] uploadBytes &#x3D; &quot;hello qiniu cloud&quot;.getBytes(&quot;utf-8&quot;);</span><br><span class="line">    Auth auth &#x3D; Auth.create(accessKey, secretKey);</span><br><span class="line">    String upToken &#x3D; auth.uploadToken(bucket);</span><br><span class="line">    try &#123;</span><br><span class="line">        Response response &#x3D; uploadManager.put(uploadBytes, key, upToken);</span><br><span class="line">        &#x2F;&#x2F;解析上传成功的结果</span><br><span class="line">        DefaultPutRet putRet &#x3D; new Gson().fromJson(response.bodyString(), DefaultPutRet.class);</span><br><span class="line">        System.out.println(putRet.key);</span><br><span class="line">        System.out.println(putRet.hash);</span><br><span class="line">    &#125; catch (QiniuException ex) &#123;</span><br><span class="line">        Response r &#x3D; ex.response;</span><br><span class="line">        System.err.println(r.toString());</span><br><span class="line">        try &#123;</span><br><span class="line">            System.err.println(r.bodyString());</span><br><span class="line">        &#125; catch (QiniuException ex2) &#123;</span><br><span class="line">            &#x2F;&#x2F;ignore</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (UnsupportedEncodingException ex) &#123;</span><br><span class="line">    &#x2F;&#x2F;ignore</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以及删除上传的文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;构造一个带指定 Region 对象的配置类</span><br><span class="line">Configuration cfg &#x3D; new Configuration(Region.region0());</span><br><span class="line">&#x2F;&#x2F;...其他参数参考类注释</span><br><span class="line">String accessKey &#x3D; &quot;your access key&quot;;</span><br><span class="line">String secretKey &#x3D; &quot;your secret key&quot;;</span><br><span class="line">String bucket &#x3D; &quot;your bucket name&quot;;</span><br><span class="line">String key &#x3D; &quot;your file key&quot;;</span><br><span class="line">Auth auth &#x3D; Auth.create(accessKey, secretKey);</span><br><span class="line">BucketManager bucketManager &#x3D; new BucketManager(auth, cfg);</span><br><span class="line">try &#123;</span><br><span class="line">    bucketManager.delete(bucket, key);</span><br><span class="line">&#125; catch (QiniuException ex) &#123;</span><br><span class="line">    &#x2F;&#x2F;如果遇到异常，说明删除失败</span><br><span class="line">    System.err.println(ex.code());</span><br><span class="line">    System.err.println(ex.response.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面有提到比较关键的信息，因为使用七牛云服务要进行认证，上面有三个数据<strong>AK、SK和bucket name</strong>，AK和SK也就是<code>AccessKey/SecretKey</code>。</p>
<p>AK和SK这个信息中可以在如下的页面获取，bucket name也就是你在创建存储空间的时候填信息的名称：</p>
<p><img src="https://img-blog.csdnimg.cn/20200912193859683.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>有了这些信息，我们可以将上面的代码封装成自己的工具类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public class QiniuUtils &#123;</span><br><span class="line">    &#x2F;&#x2F; 填写你的accessKey值</span><br><span class="line">    public  static String accessKey &#x3D; &quot;your accessKey&quot;;</span><br><span class="line">     &#x2F;&#x2F; 填写你的secretKey 值</span><br><span class="line">    public  static String secretKey &#x3D; &quot;your secretKey &quot;;</span><br><span class="line">    &#x2F;&#x2F; 填写你的 bucket name值</span><br><span class="line">    public  static String bucket &#x3D; &quot;your bucket name&quot;;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 上传文件</span><br><span class="line">     * @param filePath 文件路径</span><br><span class="line">     * @param fileName 文件名</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void uploadFile(String filePath,String fileName)&#123;</span><br><span class="line">        Configuration cfg &#x3D; new Configuration(Zone.zone0());</span><br><span class="line">        UploadManager uploadManager &#x3D; new UploadManager(cfg);</span><br><span class="line">        Auth auth &#x3D; Auth.create(accessKey, secretKey);</span><br><span class="line">        String upToken &#x3D; auth.uploadToken(bucket);</span><br><span class="line">        try &#123;</span><br><span class="line">            Response response &#x3D; uploadManager.put(filePath, fileName, upToken);</span><br><span class="line">            DefaultPutRet putRet &#x3D; new Gson().fromJson(response.bodyString(), DefaultPutRet.class);</span><br><span class="line">        &#125; catch (QiniuException ex) &#123;</span><br><span class="line">            Response r &#x3D; ex.response;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.err.println(r.bodyString());</span><br><span class="line">            &#125; catch (QiniuException ex2) &#123;</span><br><span class="line">                &#x2F;&#x2F;ignore</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 上传文件</span><br><span class="line">     * @param bytes 文件字节数组</span><br><span class="line">     * @param fileName 文件名</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void uploadFile(byte[] bytes, String fileName)&#123;</span><br><span class="line">        Configuration cfg &#x3D; new Configuration(Zone.zone0());</span><br><span class="line">        UploadManager uploadManager &#x3D; new UploadManager(cfg);</span><br><span class="line">        String key &#x3D; fileName;</span><br><span class="line">        Auth auth &#x3D; Auth.create(accessKey, secretKey);</span><br><span class="line">        String upToken &#x3D; auth.uploadToken(bucket);</span><br><span class="line">        try &#123;</span><br><span class="line">            Response response &#x3D; uploadManager.put(bytes, key, upToken);</span><br><span class="line">            DefaultPutRet putRet &#x3D; new Gson().fromJson(response.bodyString(), DefaultPutRet.class);</span><br><span class="line">        &#125; catch (QiniuException ex) &#123;</span><br><span class="line">            Response r &#x3D; ex.response;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.err.println(r.bodyString());</span><br><span class="line">            &#125; catch (QiniuException ex2) &#123;</span><br><span class="line">                &#x2F;&#x2F;ignore</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 删除文件</span><br><span class="line">     * @param fileName 文件名</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void deleteFile(String fileName)&#123;</span><br><span class="line">        Configuration cfg &#x3D; new Configuration(Zone.zone0());</span><br><span class="line">        String key &#x3D; fileName;</span><br><span class="line">        Auth auth &#x3D; Auth.create(accessKey, secretKey);</span><br><span class="line">        BucketManager bucketManager &#x3D; new BucketManager(auth, cfg);</span><br><span class="line">        try &#123;</span><br><span class="line">            bucketManager.delete(bucket, key);</span><br><span class="line">        &#125; catch (QiniuException ex) &#123;</span><br><span class="line">            System.err.println(ex.code());</span><br><span class="line">            System.err.println(ex.response.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后写一个接口作为文件上传的测试类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Autowired </span><br><span class="line">private JedisPool jedisPool; &#x2F;&#x2F;图片上传 </span><br><span class="line">@RequestMapping(&quot;&#x2F;uploadImage&quot;) </span><br><span class="line">public ResponseResult upload(@RequestParam(&quot;imgFile&quot;)MultipartFile imgFile)&#123; </span><br><span class="line">	try&#123;</span><br><span class="line">	    &#x2F;&#x2F;获取原始文件名 </span><br><span class="line">		String originalFilename &#x3D; imgFile.getOriginalFilename(); </span><br><span class="line">		&#x2F;&#x2F;获取图片名后缀 </span><br><span class="line">		int lastIndexOf &#x3D; originalFilename.lastIndexOf(&quot;.&quot;); </span><br><span class="line">		String suffix &#x3D; originalFilename.substring(lastIndexOf ‐ 1); </span><br><span class="line">		&#x2F;&#x2F;使用UUID生成图片名，防止名称一样</span><br><span class="line">		String fileName &#x3D; UUID.randomUUID().toString() + suffix; QiniuUtils.uploadFile(imgFile.getBytes(),fileName); &#x2F;&#x2F;图片上传成功 </span><br><span class="line">		ResponseResult result &#x3D; new ResponseResult (MessageConstant.UPLOAD_SUCCESS,&quot;上传成功&quot;); </span><br><span class="line">		result.setData(fileName); </span><br><span class="line">		&#x2F;&#x2F;将上传图片名称存入Redis，基于Redis的Set集合存储 </span><br><span class="line">        jedisPool.getResource().sadd(ImageConstant.ALl_PIC_RESOURCES,fileName ); </span><br><span class="line">		return result; </span><br><span class="line">	&#125;catch (Exception e)&#123; </span><br><span class="line">		e.printStackTrace(); &#x2F;&#x2F;图片上传失败 </span><br><span class="line">		return new ResponseResult (ResponseConstant.UPLOAD_FAIL,&quot;文件上传失败&quot;); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里在作为图片上传的时候使用Redis的set集合进行缓存，这样做的目的就是，用户自己点击上传文件后，填写完信息，但是后面就有可能包填写的消息取消掉。</p>
<p>这样这些图片就会成为我们的垃圾图片，若是没有存储这些图片的信息，从此也找不到这些图片，这样这些垃圾图片就会占用空间。</p>
<p>我们的解决方案就是，先把所有的这些图片还存在Redis的一个Set集合中，叫做<code>ALl_PIC_RESOURCES</code>。</p>
<p>然后把上传成功的图片还存在Redis的另一个Set集合中叫做<code>L：SUCCESS_PIC_RESOURCES</code>。</p>
<p>最后系统起一个定时任务，定期清理掉<code>ALl_PIC_RESOURCES</code>和<code>L：SUCCESS_PIC_RESOURCES</code>差值的图片数据，清理时间可以设置在晚上凌晨，这样对系统的性能影响就不会那么大。</p>
<p>定时任务可以选用Quartz，我相信这个定时任务框架应该很多人都用过，在项目中直接引入依赖坐标：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.quartz-scheduler&lt;&#x2F;groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;quartz&lt;&#x2F;artifactId&gt;</span><br><span class="line"> &lt;&#x2F;dependency&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.quartz-scheduler&lt;&#x2F;groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;quartz-jobs&lt;&#x2F;artifactId&gt;</span><br><span class="line"> &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>具体的定时任务的配置可以自行百度一下，这里只给出，定时任务清理图片的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void deleteImage()&#123;</span><br><span class="line">        &#x2F;&#x2F;比较两个Set集合得到差集，得到无效的图片名称集合</span><br><span class="line">        Set&lt;String&gt; imageSet &#x3D; redisTemplate.opsForSet().difference(&quot;ALl_PIC_RESOURCES&quot;, &quot;L：SUCCESS_PIC_RESOURCES&quot;);</span><br><span class="line">        for (String imageName : imageSet ) &#123;</span><br><span class="line">            &#x2F;&#x2F;删除图片</span><br><span class="line">            QiniuUtils.deleteFileFrom(imageName );</span><br><span class="line">            &#x2F;&#x2F;删除缓存中无用的图片</span><br><span class="line">            redisTemplate.boundSetOps(&quot;ALl_PIC_RESOURCES&quot;).remove(imageName );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好了，今天的实例讲解就到这里了，觉得有帮助的求个三连，我们下期再见。</p>
<p><img src="https://img-blog.csdnimg.cn/20200912201954954.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70#pic_center"></p>
</div><div class="index-category-tag">  <hr></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2020-10-14  <a class="commentCountImg" href="/2020/10/14/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82TCP-IP%E5%92%8CHTTP%E3%80%81HTTPS/#comment-container"><span class="display-none-class">d41d8cd98f00b204e9800998ecf8427e</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="d41d8cd98f00b204e9800998ecf8427e">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>36 m  <i class="fas fa-pencil-alt"> </i>5.4 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/10/14/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82TCP-IP%E5%92%8CHTTP%E3%80%81HTTPS/"> </a></h1><div class="content"><p><img src="https://img-blog.csdnimg.cn/20200224191350230.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"></p>
<h3 id="TCP-IP概念"><a href="#TCP-IP概念" class="headerlink" title="TCP/IP概念"></a>TCP/IP概念</h3><blockquote>
<p>TCP/IP（Transmission Control Protocol/Internet Protocol，传输控制协议/网际协议）是指能够在多个不同网络间实现信息传输的协议簇。TCP/IP协议不仅仅指的是TCP 和IP两个协议，而是指一个由FTP、SMTP、TCP、UDP、IP等协议构成的协议簇，同时是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。 TCP/IP 定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。</p>
</blockquote>
<blockquote>
<p><strong>我的理解：</strong>  互联网中的设备要相互通信，必须基于相同的方式，比如由哪一方发起通讯，使用什么语言进行通讯，怎么结束通讯这些都要事先确定，不同设备之间的通讯都需要一种规则，我们将这种规则成为协议。</p>
</blockquote>
<h5 id="TCP-IP-的分层管理图"><a href="#TCP-IP-的分层管理图" class="headerlink" title="TCP/IP 的分层管理图"></a>TCP/IP 的分层管理图</h5><p><img src="https://img-blog.csdnimg.cn/20200224204652913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"><br>TCP/IP协议中最重要的特点就是分层。由上往下分别为 应用层，传输层，网络层，数据链路层，物理层。当然也有按不同的模型分为4层或者7层的。</p>
<blockquote>
<p>为什么要分层呢？在设计的角度来讲变得灵活了，当某一层需要修改时，只需要拿掉对相应的层，实现可拔插，无需变动所有层。对于使用者来讲，屏蔽了底层复杂的传输过程。</p>
</blockquote>
<h5 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h5><p>TCP/IP模型将OSI参考模型中的会话层和表示层的功能合并到应用层实现。这一层主要的代表有DNS域名解析/http协议</p>
<h5 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h5><p>在TCP/IP模型中，传输层的功能是使源端主机和目标端主机上的对等实体可以进行会话。在传输层定义了两种服务质量不同的协议。即：传输控制协议TCP和用户数据报协议UDP.</p>
<h5 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h5><p>网络互连层是整个TCP/IP协议栈的核心。它的功能是把分组发往目标网络或主机。同时，为了尽快地发送分组，可能需要沿不同的路径同时进行分组传递。因此，分组到达的顺序和发送的顺序可能不同，这就需要上层必须对分组进行排序。网络互连层定义了分组格式和协议，即IP协议（Internet  Protocol ）。   </p>
<h5 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h5><p>该层负责 比特流在节点之间的传输，即负责物理传输，这一层的协议既与链路有关，也与传输的介质有关。通俗来说就是把计算机连接起来的物理手段。</p>
<h5 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h5><p>控制网络层与物理层之间的通信，主要功能是保证物理线路上进行可靠的数据传递。为了保证传输，从网络层接收到的数据被分割成特定的可被物理层传输的帧。帧是用来移动数据结构的结构包，他不仅包含原始数据，还包含发送方和接收方的物理地址以及纠错和控制信息。其中的地址确定了帧将发送到何处，而纠错和控制信息则确保帧无差错到达。如果在传达数据时，接收点检测到所传数据中有差错，就要通知发送方重发这一帧。</p>
<h5 id="UDP-和-TCP-的特点"><a href="#UDP-和-TCP-的特点" class="headerlink" title="UDP 和 TCP 的特点:"></a>UDP 和 TCP 的特点:</h5><ul>
<li>用户数据报协议 UDP（User Datagram Protocol）:无连接；尽最大努力的交付；面向报文；无拥塞控制；支持一对一、一对多、多对一、多对多的交互通信；首部开销小(只有四个字段：源端口、目的端口、长度、检验和)。UDP是面向报文的传输方式是应用层交给UDP多长的报文，UDP发送多长的报文，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。</li>
<li>传输控制协议 TCP（Transmission Control Protocol）:面向连接；每一个TCP连接只能是点对点的(一对一)；提供可靠交付服务；提供全双工通信；面向字节流。应用程序和TCP的交互是一次一个数据块(大小不等)，但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应该程序传送的数据块太长，TCP就可以把它划分短一些再传送。</li>
</ul>
<p><strong>UDP的首部格式:</strong><br><img src="https://img-blog.csdnimg.cn/20200224195114586.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70" alt="图片来源于网络"><br>用户数据报有两个字段：数据字段和首部字段，数据字段很简单，只有8个字节，由四个字段组成，每个字段的长度都是两个字节。各字段意义如下：</p>
<ol>
<li><strong>源端口：</strong> 源端口号，在需要给对方回信时使用。不需要是可全用0.</li>
<li><strong>目的端口号：</strong> 这在终点交付报文时必须使用。</li>
<li><strong>长度：</strong>  用户数据报UDP的长度，最小为8（仅首部）。</li>
<li><strong>校验和：</strong> 用于校验用户数据报在传输过程是否出错，出错则丢弃该报文。</li>
</ol>
<h5 id="TCP报文首部格式"><a href="#TCP报文首部格式" class="headerlink" title="TCP报文首部格式:"></a>TCP报文首部格式:</h5><p><img src="https://img-blog.csdnimg.cn/20200224200723125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70" alt="图片来源于网络"><br><strong>源端口和目的端口:</strong> 各占两个字节，分别写入源端口号和目的端口号。<br><strong>序号 ：</strong> 占4个字节；用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。<br><strong>确认号 ：</strong> 占4个字节；期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。<br><strong>数据偏移 ：</strong> 占4位；指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。<br><strong>确认 ACK ：</strong> 当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。<br>同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。<br><strong>终止 FIN ：</strong> 用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。<br><strong>窗口 ：</strong> 占2字节；窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。<br><strong>检验和：</strong> 占2个字节；检验和字段检验的范围包括首部和数据这两个部分。在计算检验和时，在TCP报文段的前面加上12字节的伪首部。<br><strong>套接字：</strong> TCP连接的端点叫做套接字或插口。端口号拼接到IP地址即构成了套接字。</p>
<h3 id="面试灵魂拷问"><a href="#面试灵魂拷问" class="headerlink" title="面试灵魂拷问"></a>面试灵魂拷问</h3><h5 id="TCP的三次握手与四次挥手"><a href="#TCP的三次握手与四次挥手" class="headerlink" title="TCP的三次握手与四次挥手"></a>TCP的三次握手与四次挥手</h5><ol>
<li>第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</li>
<li>第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</li>
<li>第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200224202030644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"></p>
<blockquote>
<p><strong>为什么要进行三次握手呢?</strong><br>第三次握手是为了防止失效的连接请求到达服器，让服务器错误打开连接。客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p>
</blockquote>
<blockquote>
<p><strong>如果此时变成两次挥手行不行？</strong><br>举个打电话的例子，比如：<br>第一次握手： A给B打电话说，你可以听到我说话吗？<br>第二次握手： B收到了A的信息，然后对A说： 我可以听得到你说话啊，你能听得到我说话吗？<br>第三次握手： A收到了B的信息，然后说可以的，我要给你发信息啦！<br><strong>结论：</strong><br>在三次握手之后，A和B都能确定这么一件事：我能听到你，你也能听到我。这样，就可以开始正常通信了。如果是两次，那将无法确定。</p>
</blockquote>
<p>当数据传送完毕,断开连接就需要进行TCP的四次挥手：</p>
<ol>
<li>第一次挥手，客户端设置seq和 ACK ,向服务器发送一个 FIN(终结)报文段。此时，客户端进入 FIN_WAIT_1<br>状态，表示客户端没有数据要发送给服务端了。</li>
<li>第二次挥手，服务端收到了客户端发送的 FIN 报文段，向客户端回了一个 ACK 报文段。</li>
<li>第三次挥手，服务端向客户端发送FIN 报文段，请求关闭连接，同时服务端进入 LAST_ACK 状态。</li>
<li>第四次挥手，客户端收到服务端发送的 FIN 报文段后，向服务端发送 ACK 报文段,然后客户端进入 TIME_WAIT状态。服务端收到客户端的 ACK 报文段以后，就关闭连接。此时，客户端等待2MSL（指一个片段在网络中最大的存活时间）后依然没有收到回复，则说明服务端已经正常关闭，这样客户端就可以关闭连接了。<br><img src="https://img-blog.csdnimg.cn/20200224204007865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70" alt="四次挥手"><br><strong>最后完整的过程</strong><br><img src="https://img-blog.csdnimg.cn/20200224204051989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"><blockquote>
<p><strong>为什么要四次挥手？</strong><br>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p>
</blockquote>
<h5 id="HTTP持久连接"><a href="#HTTP持久连接" class="headerlink" title="HTTP持久连接"></a>HTTP持久连接</h5><blockquote>
<p>如果有大量的连接，每次在连接，关闭都要经历三次握手，四次挥手，这显然会造成性能低下。因此。Http 有一种叫做 长连接（keepalive connections） 的机制。它可以在传输数据后仍保持连接，当客户端需要再次获取数据时，直接使用刚刚空闲下来的连接而无需再次握手。</p>
</blockquote>
</li>
</ol>
<h3 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h3><h5 id="什么是HTTP"><a href="#什么是HTTP" class="headerlink" title="什么是HTTP?"></a>什么是HTTP?</h5><blockquote>
<p>超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议,所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。</p>
</blockquote>
<p><strong>HTTP特点：</strong></p>
<ol>
<li>无状态：协议对客户端没有状态存储，对事物处理没有“记忆”能力，比如访问一个网站需要反复进行登录操作。</li>
<li>无连接：HTTP/1.1之前，由于无状态特点，每次请求需要通过TCP三次握手四次挥手，和服务器重新建立连接。比如某个客户机在短时间多次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以每次需要重新响应请求，需要耗费不必要的时间和流量。</li>
<li>基于请求和响应：基本的特性，由客户端发起请求，服务端响应。</li>
<li>简单快速、灵活。</li>
<li>通信使用明文、请求和响应不会对通信方进行确认、无法保护数据的完整性。</li>
</ol>
<p><strong>HTTP报文组成:</strong></p>
<ol>
<li>请求行：包括请求方法、URL、协议/版本</li>
<li>请求头(Request Header)</li>
<li>请求正文</li>
<li>状态行</li>
<li>响应头</li>
<li>响应正文</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/2020022420592825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>HTTP的缺点</strong></p>
<ol>
<li>通信使用明文（不加密），内容可能会被窃听。</li>
<li>不验证通信方的身份，因此有可能遭遇伪装。</li>
<li>无法证明报文的完整性，所以有可能已遭篡改。</li>
</ol>
<h5 id="什么是HTTPS"><a href="#什么是HTTPS" class="headerlink" title="什么是HTTPS?"></a>什么是HTTPS?</h5><blockquote>
<p>HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。<br>HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200224210039613.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"><br>HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。通常，HTTP 直接和 TCP 通信。当使用 SSL时，则演变成先和 SSL通信，再由 SSL和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披SSL协议这层外壳的 HTTP。</p>
<p><strong>HTTPS通讯方式：</strong></p>
<ol>
<li>客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。</li>
<li>Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。</li>
<li>客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</li>
<li>客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</li>
<li>Web服务器利用自己的私钥解密出会话密钥。</li>
<li>Web服务器利用会话密钥加密与客户端之间的通信。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200224210431615.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"></p>
<h3 id="为什么HTTPS安全"><a href="#为什么HTTPS安全" class="headerlink" title="为什么HTTPS安全"></a>为什么HTTPS安全</h3><ol>
<li>SSL不仅提供加密处理，加密方式为混合加密。</li>
<li>SSL而且还使用了一种被称为证书的手段，可用于确定方。证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。另外，伪造证书从技术角度来说是异常困难的一件事。所以只要能够确认通信方（服务器或客户端）持有的证书。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200224214342679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"><br><strong>加密方法</strong></p>
<blockquote>
<p><strong>对称加密：</strong><br>加密和解密同用一个密钥的方式称为共享密钥加密（Common keycrypto system），也被叫做对称密钥加密.</p>
</blockquote>
<p>对成加密的方式效率比较低，加密速度慢。另外对称加密存在安全隐患的问题，堆成加密的密钥必须要传到对方对方才能解密，要是对方在密钥传输的过程获取到密钥，那不是密钥失去了加密的意义，所以完全使用对称加密也是不安全的。</p>
<blockquote>
<p><strong>非对称加密：</strong><br>公开密钥加密使用一对非对称的密钥。一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。顾名思义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。公钥加密，私钥解密<br>使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。</p>
</blockquote>
<p>那么非对称个加密就一定安全吗？非对称加密也不安全，为什么呢？因为存在中间伪造公钥和私钥，假如在公钥传给对方的时候，有人获取到公钥，虽然她不能用你的公钥做什么，但是它截获公钥后，把自己伪造的公钥发送给对方，这样对方获取的就不是真正的公钥，当对方用公钥进行加密文件，再将文件发送给对方，这样即使截获人没有获取到真正的私钥，但是加密时的公钥是截获人的，他获取到加密文件，只需要用自己的私钥进行解密就成功获取到文件了。</p>
<blockquote>
<p><strong>混合加密机制（对称加密与非对称加密结合的方式）</strong><br>顾名思义也就是对称加密和非对称加密的方式相结合。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200224222231967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"><br>如何证明公开没要本身的真实性。因为在公开秘钥传输的过程中，可能真正的公开秘钥已经被攻击者替换掉了。</p>
<p>为了解决上述问题，于是除了CA认证证书。服务器将CA证书发送给客户端，以进行公开密钥加密方式通信。接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，客户端便可明确两件事：<br>一，认证服务器的公开密钥的是真实有效的数字证书认证机构。<br>二，服务器的公开密钥是值得信赖的。</p>
<p>那么公开密钥如何交接给客户端是一件非常重要的事，因此多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥，这样就确保公钥是使用认证机构的公钥避免了公钥伪造的过程，进而确保了安全。</p>
<p><img src="https://img-blog.csdnimg.cn/20200224223517734.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"></p>
</div><div class="index-category-tag">  <hr></div></article></div><!--!--><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2020-10-14  <a class="commentCountImg" href="/2020/10/14/%E8%BF%98%E5%9C%A8%E5%AD%A6JVM%EF%BC%9F%E6%88%91%E9%83%BD%E5%B8%AE%E4%BD%A0%E6%80%BB%E7%BB%93%E5%A5%BD%E4%BA%86%EF%BC%88%E9%99%84%E8%84%91%E5%9B%BE%EF%BC%89/#comment-container"><span class="display-none-class">d41d8cd98f00b204e9800998ecf8427e</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="d41d8cd98f00b204e9800998ecf8427e">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>24 m  <i class="fas fa-pencil-alt"> </i>3.6 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/10/14/%E8%BF%98%E5%9C%A8%E5%AD%A6JVM%EF%BC%9F%E6%88%91%E9%83%BD%E5%B8%AE%E4%BD%A0%E6%80%BB%E7%BB%93%E5%A5%BD%E4%BA%86%EF%BC%88%E9%99%84%E8%84%91%E5%9B%BE%EF%BC%89/"> </a></h1><div class="content"><h3 id="本文脑图"><a href="#本文脑图" class="headerlink" title="本文脑图"></a>本文脑图</h3><p><img src="https://img-blog.csdnimg.cn/20200325201535799.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70#pic_center"></p>
<h3 id="运行时数据区模型"><a href="#运行时数据区模型" class="headerlink" title="运行时数据区模型"></a>运行时数据区模型</h3><p>在java虚拟机中把内存分为若干个不同的数据区域。这些区域有各自的用途，有些区域随着虚拟机进程启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。在JVM中主要分为以下几个区域：</p>
<ol>
<li>程序计数器</li>
<li>方法区</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
<li>java堆</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200325205252427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器是内存中较小的一部分区域，是当前线程执行的字节码的行号指示器。在字节码解释器工作时通过计数器的值来选取下一条指令。</p>
<blockquote>
<p><strong>为什么需要计数器？</strong><br>多线程情况下，一条线程中有多个指令，为了使线程切换可以恢复到正确执行位置，每个线程都具有各自独立的程序计数器，所以该区域是非线程共享的内存区域。</p>
</blockquote>
<p>如果执行的是Java方法，计数器记录的是正在执行的字节码指令的地址；若执行的是Native方法，计数器存储为空。<strong>这块内存区域是虚拟机规范中唯一没有OutOfMemoryError的区域。</strong></p>
<p>我们可以得出程序计数器主要有两个作用：</p>
<ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ol>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区也称”<code>永久代</code>“，它用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，是各个线程共享的内存区域。</p>
<p>在JDK8之前的HotSpot JVM，存放这些”永久的”的区域叫做“<code>永久代(permanent generation)</code>”。永久代是一片连续的堆空间，在JVM启动之前通过在命令行设置参数<code>-XX:MaxPermSize</code>来设定永久代最大可分配的内存空间，默认大小是64M（64位JVM默认是85M）。</p>
<p>方法区或永生代相关设置</p>
<ul>
<li><code>-XX:PermSize=64MB</code> 最小尺寸，初始分配</li>
<li><code>-XX:MaxPermSize=256MB</code> 最大允许分配尺寸，</li>
<li>按需分配<code>XX:+CMSClassUnloadingEnabled</code>  </li>
<li><code>-XX:+CMSPermGenSweepingEnabled</code> 设置垃圾不回收</li>
<li><code>-server</code>选项下默认<code>MaxPermSize为64m</code>，<code>-client</code>选项下默认<code>MaxPermSize为32m</code></li>
</ul>
<p>java虚拟机规范堆方法去区限制非常的宽松，可以不选择垃圾回收，以及不需要连续的内存和可扩展的大小。这个区域主要是针对于<strong>常量池的回收以及对类型的卸载</strong>，当方法区无法分配到足够的内存的时候也会抛出OOM。</p>
<h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>虚拟机栈是每个java方法的内存模型：每个方法被执行的时候都会创建一个”栈帧”,用于存储<strong>局部变量表(包括参数)、操作栈、方法出口</strong>等信息。每个方法被调用到执行完的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<p>平时说的栈一般指局部变量表部分。栈帧对应的结构图，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200325215111988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"><br>局部变量表所需要的空间在编译期完成分配，当执行一个方法时，该方法需要在栈帧中分配多大的局部变量表的空间完全是可以确定的，因此在方法运行的期间不会改变局部变量表的大小。</p>
<p>初级程序员可能笼统的将Java内存分为<strong>堆内存</strong>和<strong>栈内存</strong>时，该区域就是常说的栈内存，该区域的局部变量表存放<strong>基本类型、对象的引用类型</strong>，在对象的引用类型中存储的是指向<strong>对象的地址</strong>。</p>
<p>该区域会出现两种异常</p>
<ol>
<li>当线程请求的栈深度大于虚拟机所允许的深度，就会抛出<code>StackOverflowError</code>异常。</li>
<li>一般虚拟机的内存都是<strong>动态扩展</strong>的，但是有可能动态的扩展还是配不到足够的内存，就会抛出OOM异常。</li>
</ol>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务。</p>
<p>本地方法栈为虚拟机使用到的native方法服务，可能底层调用的c或者c++,我们打开jdk安装目录可以看到也有很多用c编写的文件，可能就是native方法所调用的c代码。</p>
<h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p><code>Java 堆（Java Heap</code>）是Java 虚拟机所管理的<strong>内存中最大的一块</strong>。Java 堆是被<strong>所有线程共享</strong>的一块内存区域，在虚拟机启动时创建。</p>
<p>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。堆内存是<strong>所有线程共有的</strong>，可以分为两个部分：<strong>年轻代</strong>和<strong>老年代</strong>。</p>
<blockquote>
<p>注意:它是所有线程共享的，它的目的是存放对象实例。同时它也是GC所管理的主要区域，因此常被称为<strong>GC堆</strong>。根据虚拟机规范，Java堆可以存在物理上不连续的内存空间，就像磁盘空间只要逻辑是连续的即可。它的内存大小可以设为固定大小，也可以扩展。当前主流的虚拟机如HotPot都能按扩展实现(通过设置 <code>-Xmx</code>和<code>-Xms</code>)，如果堆中没有内存内存完成实例分配，而且堆无法扩展将报OOM错误(OutOfMemoryError)</p>
</blockquote>
<p>新生代又分为：<code>Eden</code>空间、<code>From Survivor</code>、<code>To Survivor</code>空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。</p>
<p><strong>分代回收</strong>的原因：<strong>对象的生命周期不同</strong>，所以针对不同生命周期的对象可以采取不同的回收方式，以便提高回收效率。从内存分配的角度来看，线程共享的java堆中可能会划分出<strong>多个线程私有的分配缓冲区</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/20200325221303109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"></p>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h4><p><strong>标记-清除</strong>是最基本的回收算法，后面的算法的设计的思想都是基于此算法进行设计。标记-清除算法一共分为两个阶段<strong>标记</strong>和<strong>清除</strong>阶段，标记阶段是将不可达的对象（即为不存活的对象）进行标记，接着清除阶段将这些标记的对象进行清除。<br><img src="https://img-blog.csdnimg.cn/20200325230313475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"><br>标记-清除算法主要有<strong>两个问题</strong>：一个是<strong>效率的问题</strong>，标记和清除两个过程效率都不高；另一个问题就是该算法会<strong>产生很多的内存碎片</strong>，大量的不连续内存空间，当程序需要申请较大的内存空间存储大对象的时候，有可能无法申请到足够的内存空间而不得不再一次触发一次垃圾回收动作。</p>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>复制算法将<strong>内存划分为两个区间</strong>，在任意时间点，所有动态分配的对象都只能分配在其中一个区间（<strong>称为活动区间</strong>），而另外一个区间（<strong>称为空闲区间</strong>）则是空闲的。</p>
<p>当有效内存空间耗尽时，JVM将暂停程序运行，开启复制算法GC线程。接下来GC线程会将活动区间内的存活对象，全部复制到空闲区间，且严格按照内存地址依次排列，与此同时，GC线程将更新存活对象的内存引用地址指向新的内存地址。</p>
<p>此时，空闲区间已经与活动区间交换，而垃圾对象现在已经全部留在了原来的活动区间，也就是现在的空闲区间。事实上，在活动区间转换为空间区间的同时，垃圾对象已经被一次性全部回收。<br><img src="https://img-blog.csdnimg.cn/20200325230339182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"></p>
<p>新生代中因为对象都是”朝生夕死的”，深入理解JVM虚拟机上说98%的对象存活率很低，适用于复制算法，复制算法比较适合用于存活率低的内存区域。它优化了标记/清除算法的效率和内存碎片问题。</p>
<p>JVM不是平分内存，新生代中由于存活率低，不需要复制保留那么大的区域造成空间上的浪费，因此不需要按1:1划分内存区域，而是将内存分为一块Eden空间和From Survivor、To Survivor【保留空间】。</p>
<p>（1）新生代：大多数对象在新生代中被创建，其中很多对象的生命周期很短。每次新生代的垃圾回收（又称<strong>Minor GC</strong>）后只有少量对象存活，所以选用<strong>复制算法</strong>，只需要少量的复制成本就可以完成回收。</p>
<blockquote>
<p>在新生代内存中每次只是用Eden和其中的一个S区。当Eden区满时，还存活的对象将被复制到两个<code>Survivor区</code>中的一个。当这个Survivor区满时，此区的存活且不满足“晋升”条件的对象将被复制到另外一个Survivor区。</p>
</blockquote>
<blockquote>
<p>对象每经历一次<code>Minor GC</code>，年龄加1，达到“晋升年龄阈值”后，被放到老年代，这个过程也称为“晋升”。显然，“晋升年龄阈值”的大小直接影响着对象在新生代中的停留时间，在<code>Serial</code>和<code>ParNew GC</code>两种回收器中，“晋升年龄阈值”通过参数<code>MaxTenuringThreshold</code>设定，默认值为15。</p>
</blockquote>
<p>（2）老年代：在新生代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代，该区域中对象存活率高。老年代的垃圾回收（又称<strong>Major GC</strong>）通常使用<strong>标记-清理</strong>或<strong>标记-整理</strong>算法。整堆包括新生代和老年代的垃圾回收称为<strong>Full GC</strong>。</p>
<p>（3）永久代：主要存放元数据，例如<code>Class</code>、<code>Method</code>的元信息，与垃圾回收要回收的Java对象关系不大。相对于新生代和年老代来说，该区域的划分对垃圾回收影响比较小。在 <strong>JDK 1.8中移除整个永久代</strong>，取而代之的是一个叫<strong>元空间</strong>的区域。</p>
<blockquote>
<p>默认的Eden : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )，即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。</p>
</blockquote>
<p>在新生代中，并不是每次存活的对象都少于10%，有时候若是存活的对象大于10%，就会想老年代进行<strong>空间分配担保</strong>。</p>
<h4 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h4><p>标记-整理算法也分为两步，首先标记不可达的对象，然后存活的对象往一端移动，然后直接清理掉端边界以外的内存。</p>
<p>老年代中存活率比较高，要是使用复制算法，会大量浪费时间在复制对象上，因此复制算法不适合用在存活率比较高的场景。<br><img src="https://img-blog.csdnimg.cn/20200325231111199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"><br>标记的存活对象将会被整理，按照<strong>内存地址依次排列</strong>，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个<strong>内存的起始地址</strong>即可，这比维护一个空闲列表显然少了许多开销。</p>
<p>不难看出，标记/整理算法不仅可以弥补标记/清除算法当中，内存区域分散的缺点，也消除了复制算法当中，内存减半的高额代价。</p>
<p>不过任何算法都会有其缺点，标记/整理算法唯一的缺点就是效率也不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。从效率上来说，<strong>标记/整理算法要低于复制算法</strong>。</p>
<blockquote>
<p>关于JVM深入研究以及JVM调优，后面的文章会继续深入，这篇文章先介绍JVM的内存模型，以及回收算法。</p>
</blockquote>
</div><div class="index-category-tag">  <hr></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2020-10-14  <a class="commentCountImg" href="/2020/10/14/%E5%88%AB%E5%86%8D%E9%97%AE%E6%88%91Redis%E5%86%85%E5%AD%98%E6%BB%A1%E4%BA%86%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E%E4%BA%86/#comment-container"><span class="display-none-class">d41d8cd98f00b204e9800998ecf8427e</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="d41d8cd98f00b204e9800998ecf8427e">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>17 m  <i class="fas fa-pencil-alt"> </i>2.5 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/10/14/%E5%88%AB%E5%86%8D%E9%97%AE%E6%88%91Redis%E5%86%85%E5%AD%98%E6%BB%A1%E4%BA%86%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E%E4%BA%86/"> </a></h1><div class="content"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>Redis</code>的文章，我之前写过一篇关于<strong>Redis的缓存的三大问题</strong>，累计阅读也快800了，对于还只有3k左右的粉丝量，能够达到这个阅读量，已经是比较难了。</p>
<p>这说明那篇文章写的还过得去，收到很多人的阅读肯定，感兴趣的看一下[]。</p>
<p><strong>三大缓存问题</strong>只是Redis的其中的一小部分的知识点，想要深入学习Redis还要学习比较多的知识点。</p>
<p>那么今天就带来了一个面试常问的一个问题：<strong>假如你的Redis内存满了怎么办？</strong> 长期的把Redis作为缓存使用，总有一天会存满的时候对吧。</p>
<p>这个面试题不慌呀，在Redis中有配置参数<code>maxmemory</code>可以<strong>设置Redis内存的大小</strong>。</p>
<p>在Redis的配置文件<code>redis.conf</code>文件中，配置<code>maxmemory</code>的大小参数如下所示：<br><img src="https://img-blog.csdnimg.cn/20200519220333869.png"><br>实际生产中肯定不是<code>100mb</code>的大小哈，不要给误导了，这里我只是让大家认识这个参数，一般小的公司都是设置为<code>3G</code>左右的大小。</p>
<p>除了在配置文件中配置生效外，还可以通过命令行参数的形式，进行配置，具体的配置命令行如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取maxmemory配置参数的大小</span><br><span class="line">127.0.0.1:6379&gt; config get maxmemory</span><br><span class="line">&#x2F;&#x2F;设置maxmemory参数为100mb</span><br><span class="line">127.0.0.1:6379&gt; config set maxmemory 100mb</span><br></pre></td></tr></table></figure>

<p>倘若实际的存储中超出了Redis的配置参数的大小时，Redis中有<strong>淘汰策略</strong>，把<strong>需要淘汰的key给淘汰掉，整理出干净的一块内存给新的key值使用</strong>。</p>
<p>接下来我们就详细的聊一聊Redis中的淘汰策略，并且深入的理解每个淘汰策略的原理和应用的场景。</p>
<h2 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h2><p>Redis提供了<strong>6种的淘汰策略</strong>，其中默认的是<code>noeviction</code>，这6中淘汰策略如下：</p>
<ol>
<li><code>noeviction</code>(<strong>默认策略</strong>)：若是内存的大小达到阀值的时候，所有申请内存的指令都会报错。</li>
<li><code>allkeys-lru</code>：所有key都是使用<strong>LRU算法</strong>进行淘汰。</li>
<li><code>volatile-lru</code>：所有<strong>设置了过期时间的key使用LRU算法</strong>进行淘汰。</li>
<li><code>allkeys-random</code>：所有的key使用<strong>随机淘汰</strong>的方式进行淘汰。</li>
<li><code>volatile-random</code>：所有<strong>设置了过期时间的key使用随机淘汰</strong>的方式进行淘汰。</li>
<li><code>volatile-ttl</code>：所有设置了过期时间的key<strong>根据过期时间进行淘汰，越早过期就越快被淘汰</strong>。</li>
</ol>
<p>假如在Redis中的数据有<strong>一部分是热点数据，而剩下的数据是冷门数据</strong>，或者<strong>我们不太清楚我们应用的缓存访问分布状况</strong>，这时可以使用<code>allkeys-lru</code>。</p>
<p>假如所有的数据访问的频率大概一样，就可以使用<code>allkeys-random</code>的淘汰策略。</p>
<p>假如要配置具体的淘汰策略，可以在<code>redis.conf</code>配置文件中配置，具体配置如下所示：<br><img src="https://img-blog.csdnimg.cn/20200519225413746.png"><br>这只需要把注释给打开就可以，并且配置指定的策略方式，另一种的配置方式就是命令的方式进行配置，具体的执行命令如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取maxmemory-policy配置</span><br><span class="line">127.0.0.1:6379&gt; config get maxmemory-policy</span><br><span class="line">&#x2F;&#x2F; 设置maxmemory-policy配置为allkeys-lru</span><br><span class="line">127.0.0.1:6379&gt; config set maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure>
<p>在介绍6种的淘汰策略方式的时候，说到了LRU算法，<strong>那么什么是LRU算法呢？</strong></p>
<h2 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h2><p><code>LRU(Least Recently Used)</code>即表示最近最少使用，也就是在最近的时间内最少被访问的key，算法根据数据的历史访问记录来进行淘汰数据。</p>
<p>它的核心的思想就是：<strong>假如一个key值在最近很少被使用到，那么在将来也很少会被访问</strong>。</p>
<p>实际上Redis实现的LRU并不是真正的LRU算法，也就是名义上我们使用LRU算法淘汰键，但是实际上被淘汰的键并不一定是真正的最久没用的。</p>
<p>Redis使用的是近似的LRU算法，<strong>通过随机采集法淘汰key，每次都会随机选出5个key，然后淘汰里面最近最少使用的key</strong>。</p>
<p>这里的5个key只是默认的个数，具体的个数也可以在配置文件中进行配置，在配置文件中的配置如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200519231937596.png"><br>当近似LRU算法取值越大的时候就会越接近真实的LRU算法，可以这样理解，因为<strong>取值越大那么获取的数据就越全，淘汰中的数据的就越接近最近最少使用的数据</strong>。</p>
<p>那么为了实现根据时间实现LRU算法，Redis必须为每个key中额外的增加一个内存空间用于存储每个key的时间，大小是3字节。</p>
<p>在Redis 3.0中对近似的LRU算法做了一些优化，Redis中会维护大小是<code>16</code>的一个候选池的内存。</p>
<p>当第一次随机选取的采样数据，数据都会被放进候选池中，并且候选池中的数据会根据时间进行排序。</p>
<p>当第二次以后选取的数据，只有<strong>小于候选池内的最小时间</strong>的才会被放进候选池中。</p>
<p>当某一时刻候选池的数据满了，那么时间最大的key就会被挤出候选池。当执行淘汰时，直接从候选池中选取最近访问时间最小的key进行淘汰。</p>
<p>这样做的目的就是选取出最近似符合最近最少被访问的key值，能够正确的淘汰key值，因为随机选取的样本中的最小时间可能不是真正意义上的最小时间。</p>
<p>但是LRU算法有一个弊端：就是假如一个key值在以前都没有被访问到，然而最近一次被访问到了，那么就会认为它是热点数据，不会被淘汰。</p>
<p>然而有些数据以前经常被访问到，只是最近的时间内没有被访问到，这样就导致这些数据很可能被淘汰掉，这样一来就会出现误判而淘汰热点数据。</p>
<p>于是在Redis 4.0的时候除了LRU算法，新加了一种LFU算法，<strong>那么什么是LFU算法算法呢？</strong></p>
<h2 id="LFU算法"><a href="#LFU算法" class="headerlink" title="LFU算法"></a>LFU算法</h2><p><code>LFU(Least Frequently Used)</code>即表示最近频繁被使用，也就是最近的时间段内，频繁被访问的key，它以最近的时间段的被访问次数的频率作为一种判断标准。</p>
<p>它的核心思想就是：根据key最近被访问的频率进行淘汰，比较少被访问的key优先淘汰，反之则优先保留。</p>
<p>LFU算法反映了一个key的热度情况，不会因为LRU算法的偶尔一次被访问被认为是热点数据。</p>
<p>在LFU算法中支持<code>volatile-lfu</code>策略和<code>allkeys-lfu</code>策略。</p>
<p>以上介绍了Redis的6种淘汰策略，这6种淘汰策略旨在告诉我们怎么做，但是什么时候做？这个还没说，下面我们就来详细的了解Redis什么时候执行淘汰策略。</p>
<h2 id="删除过期键策略"><a href="#删除过期键策略" class="headerlink" title="删除过期键策略"></a>删除过期键策略</h2><p>在Redis种有三种删除的操作此策略，分别是：</p>
<ol>
<li><strong>定时删除</strong>：创建一个定时器，定时的执行对key的删除操作。</li>
<li><strong>惰性删除</strong>：每次只有再访问key的时候，才会检查key的过期时间，若是已经过期了就执行删除。</li>
<li><strong>定期删除</strong>：每隔一段时间，就会检查删除掉过期的key。</li>
</ol>
<p><strong>定时删除</strong>对于<strong>内存来说是友好的</strong>，定时清理出干净的空间，但是对于<strong>cpu来说并不是友好的</strong>，程序需要维护一个定时器，这就会占用cpu资源。</p>
<p><strong>惰性的删除</strong>对于<strong>cpu来说是友好的</strong>，cpu不需要维护其它额外的操作，但是对于<strong>内存来说是不友好的</strong>，因为要是有些key一直没有被访问到，就会一直占用着内存。</p>
<p>定期删除是上面两种方案的折中方案<strong>，每隔一段时间删除过期的key，也就是根据具体的业务，合理的取一个时间定期的删除key</strong>。</p>
<p>通过<strong>最合理控制删除的时间间隔</strong>来删除key，减<strong>少对cpu的资源的占用消耗</strong>，使删除操作合理化。</p>
<h2 id="RDB和AOF-的淘汰处理"><a href="#RDB和AOF-的淘汰处理" class="headerlink" title="RDB和AOF 的淘汰处理"></a>RDB和AOF 的淘汰处理</h2><p>在Redis中持久化的方式有两种<code>RDB</code>和<code>AOF</code>，具体这两种详细的持久化介绍，可以参考这一篇文章[]。</p>
<p>在RDB中是以快照的形式获取内存中某一时间点的数据副本，在创建RDB文件的时候可以通过<code>save</code>和<code>bgsave</code>命令执行创建RDB文件。</p>
<p><strong>这两个命令都不会把过期的key保存到RDB文件中</strong>，这样也能达到删除过期key的效果。</p>
<p>当在启动Redis载入RDB文件的时候，<code>Master</code>不会把过期的key载入，而<code>Slave</code>会把过期的key载入。</p>
<p>在AOF模式下，Redis提供了Rewite的优化措施，执行的命令分别是<code>REWRITEAOF</code>和<code>BGREWRITEAOF</code>，<strong>这两个命令都不会把过期的key写入到AOF文件中，也能删除过期key</strong>。</p>
</div><div class="index-category-tag">  <hr></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2020-10-14  <a class="commentCountImg" href="/2020/10/14/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90AQS%E5%92%8CCAS%EF%BC%8C%E7%9C%8B%E4%BA%86%E9%83%BD%E8%AF%B4%E5%A5%BD/#comment-container"><span class="display-none-class">d41d8cd98f00b204e9800998ecf8427e</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="d41d8cd98f00b204e9800998ecf8427e">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>22 m  <i class="fas fa-pencil-alt"> </i>3.3 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/10/14/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90AQS%E5%92%8CCAS%EF%BC%8C%E7%9C%8B%E4%BA%86%E9%83%BD%E8%AF%B4%E5%A5%BD/"> </a></h1><div class="content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不知不觉写文章已经快半年了，本来之前写文章只是为了自己总结知识，不知不觉中关注的朋友越来越多了。</p>
<p>现在写文章不单单只是为了考虑自己能看懂，还要考虑各位读者大大是否能看懂，考虑输出文章的质量。</p>
<p>现在的每一次写作就好像在搞一次艺术品，细细雕琢，进行每一次的加工。文章的<strong>逻辑性</strong>，<strong>易懂性</strong>，还有<strong>文章的排版的美观度</strong>，都要细细斟酌。</p>
<p>写在前面先来一碗鸡汤：<strong>世界上并没有什么救世主，假如有那便是你自己；世界上也没有什么奇迹，假如有那只是努力的另一个名字罢了。</strong></p>
<p>想想自己毕业差不多一年来走过来的路，看看现在的自己，一切都值得，往后还会不断的努力，看到越来越强的自己。</p>
<p>话不多说下面就直接上干货了，今天来深入的了解<code>CAS</code>和<code>AQS</code>，文章采用层次式、图文并茂的方式一层一层的进行剖析，让各位读者大大能够深入理解。</p>
<h2 id="AQS简介"><a href="#AQS简介" class="headerlink" title="AQS简介"></a>AQS简介</h2><p><code>AQS（AbstractQueuedSynchronizer）</code>为<strong>抽象队列同步器</strong>，简单的说<strong>AQS就是一个抽象类</strong>，抽象类就是<code>AbstractQueuedSynchronizer</code>，没有实现任何的接口，<strong>仅仅定义了同步状态（state）的获取和释放的方法</strong>。</p>
<p>它提供了一个<strong>FIFO队列</strong>，多线程竞争资源的时候，没有竞争到的线程就会进入队列中进行等待，并且<strong>定义了一套多线程访问共享资源的同步框架</strong>。</p>
<p>在AQS中的锁类型有两种：分别是<strong>Exclusive(独占锁)**和</strong>Share(共享锁)**。</p>
<p><strong>独占锁</strong>就是<strong>每次都只有一个线程运行</strong>，例如<code>ReentrantLock</code>。关于ReentrantLock之前写过一片详细的源码文章，喜欢的可以看一看[]。</p>
<p><strong>共享锁</strong>就是<strong>同时可以多个线程运行</strong>，如<code>Semaphore、CountDownLatch、ReentrantReadWriteLock</code>。</p>
<h2 id="AQS源码分析"><a href="#AQS源码分析" class="headerlink" title="AQS源码分析"></a>AQS源码分析</h2><p>在AQS的源码可以看到对于<strong>state共享变量</strong>，使用<strong>volatile关键字</strong>进行修饰，从而<strong>保证了可见性</strong>，若是对于volatile关键字不熟悉的可以参考这一篇[]。<br><img src="https://img-blog.csdnimg.cn/20200523205526312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20200523205539901.png"><br>从上面的源码中可以看出，对于state的修改操作提供了<code>setState</code>和<code>compareAndSetState</code>，<strong>那么为什么要提供这两个对state的修改呢？</strong></p>
<p>因为<code>compareAndSetState</code>方法<strong>通常使用在获取到锁之前</strong>，当前线程不是锁持有者，对于state的修改可能存在线程安全问题，所以<strong>需要保证对state修改的原子性操作</strong>。</p>
<p>而<code>setState</code>方法通常用于当前正持有锁的线程对<strong>state共享变量</strong>进行修改，因为不存在竞争，是线程安全的，所以没必要使用CAS操作。</p>
<p>分析了AQS的源码的实现，接下来我们看看AQS的实现的原理。这里AQS的实现源码和理论都会比较简单，因为还没有涉及到具体的实现类。</p>
<h2 id="AQS实现原理"><a href="#AQS实现原理" class="headerlink" title="AQS实现原理"></a>AQS实现原理</h2><p>上面说到AQS中维护了一个<strong>FIFO队列</strong>，并且<strong>该队列式一个双向链表</strong>，链表中的每一个节点为<strong>Node节点</strong>，<strong>Node类是AbstractQueuedSynchronizer中的一个内部类</strong>。</p>
<p>让我们来看看AQS中Node内部类的源码，这样有助于我们能够对AQS的内部的实现更加的清晰：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">static final class Node &#123;</span><br><span class="line"></span><br><span class="line">       static final Node SHARED &#x3D; new Node();</span><br><span class="line">       static final Node EXCLUSIVE &#x3D; null;</span><br><span class="line">       static final int CANCELLED &#x3D;  1;</span><br><span class="line">       static final int SIGNAL    &#x3D; -1;</span><br><span class="line">       static final int CONDITION &#x3D; -2;</span><br><span class="line">       static final int PROPAGATE &#x3D; -3;</span><br><span class="line">       volatile int waitStatus;</span><br><span class="line">       volatile Node prev;</span><br><span class="line">       volatile Node next;</span><br><span class="line">       volatile Thread thread;</span><br><span class="line">       Node nextWaiter;</span><br><span class="line"></span><br><span class="line">       final boolean isShared() &#123;</span><br><span class="line">           return nextWaiter &#x3D;&#x3D; SHARED;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       final Node predecessor() throws NullPointerException &#123;</span><br><span class="line">           Node p &#x3D; prev;</span><br><span class="line">           if (p &#x3D;&#x3D; null)</span><br><span class="line">               throw new NullPointerException();</span><br><span class="line">           else</span><br><span class="line">               return p;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Node() &#123;    &#x2F;&#x2F; Used to establish initial head or SHARED marker</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Node(Thread thread, Node mode) &#123;     &#x2F;&#x2F; Used by addWaiter</span><br><span class="line">           this.nextWaiter &#x3D; mode;</span><br><span class="line">           this.thread &#x3D; thread;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Node(Thread thread, int waitStatus) &#123; &#x2F;&#x2F; Used by Condition</span><br><span class="line">           this.waitStatus &#x3D; waitStatus;</span><br><span class="line">           this.thread &#x3D; thread;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到上面的Node类比较简单，只是对于每个Node节点拥有的属性进行维护，在Node内部类中最重要的基本构成就是这几个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">volatile Node prev;</span><br><span class="line">volatile Node next;</span><br><span class="line">volatile Thread thread;</span><br></pre></td></tr></table></figure>

<p><strong>根据源码的分析和线程的竞争共享资源的原理</strong>，关于AQS的实现原理，我这里画了一张图：<br><img src="https://img-blog.csdnimg.cn/20200524102317514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"><br>在FIFO队列中，<strong>头节点占有锁</strong>，也就是头节点才是锁的持有者，尾指针指向队列的最后一个等待线程节点，除了头节点和尾节点，节点之间都有<strong>前驱指针</strong>和<strong>后继指针</strong></p>
<p>在AQS中维护了一个<strong>共享变量state</strong>，标识当前的资源是否被线程持有，多线程竞争的时候，会去判断state是否为0，尝试的去把state修改为1</p>
<p>分析了AQS的源码的实现和原理实现，但是AQS里面具体是没有做同步的具体实现，如果要什么了解AQS的具体的实现原理，要需要看AQS的具体实现类，这边就以<code>ReentrantLock</code>为例。</p>
<h2 id="ReentrantLock实现原理"><a href="#ReentrantLock实现原理" class="headerlink" title="ReentrantLock实现原理"></a>ReentrantLock实现原理</h2><p>如果多线程在竞争共享资源时，<strong>竞争失败的线程就会添加入FIFO队列的尾部</strong>。</p>
<p>在<code>ReentrantLock</code>的的具体实现中，这边以在ReentrantLock的非公平锁的实现为例，因为公平锁的实现，之前已经写过一篇文章分析过了。</p>
<p>我们来看看新添加节点的源码写的实现逻辑：<br><img src="https://img-blog.csdnimg.cn/20200524111813202.png"><br>当竞争锁资源的线程失败后直接进入<code>acquire(1)</code>方法，来来看看acquire(1)的具体实现：<br><img src="https://img-blog.csdnimg.cn/20200524112941821.png"><br>从源码中可以看出，acquire(1)的实现主要有这三步的逻辑：</p>
<ol>
<li><code>tryAcquire(arg)</code>：尝试再次获取锁。</li>
<li><code>addWaiter(Node.EXCLUSIVE)</code>：若是获取锁失败，就会将当前线程组装成一个Node节点，进行如对操作。</li>
<li><code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</code>：acquireQueued方法以addWaiter返回的头节点作为参数，内部实现进行锁自旋，以及判断是否应该执行线程挂起。</li>
</ol>
<p>下面我们再来看看<code>tryAcquire(arg)</code>的源码，从上面的看一看出arg的值为1，具体的实现源码如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200524114040402.png"><br><img src="https://img-blog.csdnimg.cn/20200524114601357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"><br>从源码的分析中可以看出，<code>tryAcquire(arg)</code>的实现也就是判断state的值是否已经被释放，<strong>若释放则当前线程就会CAS操作将state设置为1，若是没有释放，就会判断是否可以进行锁的重入</strong>。</p>
<p>分析完<code>tryAcquire(arg)</code>的实现，来看看<code>addWaiter</code>，入队操作的实现源码如下：<br><img src="https://img-blog.csdnimg.cn/20200524115714433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"><br>从上面的源码分析，可以看出对于新加入的线程添加到双向链表中使用尾插法，具体的实现原理图如下所示。<br><img src="https://img-blog.csdnimg.cn/20200524110339619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"><br>从上图分析，当线程假如队列中，主要进行这几步操作<strong>新加入的节点prev指针指向原来的tail节点，原来的tail节点的next指针指向新加入的节点</strong>，这个也就是常见的<strong>双向列表尾插法</strong>的操作。</p>
<p><strong>最后把tail指向新加入的节点</strong>，如此一来就完成了新加入节点的入队操作，接下来我们接着分析源码。</p>
<p>当然这里的前提是<strong>队列中不为空</strong>，若是为空的话，不会走上面的逻辑，而是走<code>enq(node)</code>，进行初始化节点，我们来看看<code>enq(node)</code>操作，源码如下：<br><img src="https://img-blog.csdnimg.cn/20200524120643698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"><br>执行完上面的入对操作后，接着执行<code>acquireQueued</code>方法，来看看它的具体实现源码：<br><img src="https://img-blog.csdnimg.cn/2020052412181374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"><br>从上上面的源码中可以看出，涉及到<strong>头节点head的出队</strong>操作，并且将<strong>当前线程的node节点晋升为head节点</strong>。</p>
<p>因为只有<strong>头节点才是锁的持有者</strong>，所以对于head节点的出队操作，head的指向会随时改变，我这里画了一张原理图如下所示：<br><img src="https://img-blog.csdnimg.cn/20200524104716597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"><br>具体实现如上图所示，会把<strong>原来的头节点进行出队操作，也就是把原来的头节点next指针指向null，原来第二节点的prev指针指向null</strong>。</p>
<p>最后把head指针指向第二节点，当然thread2同时还会修改共享状态变量state的值，如此一来就完成了锁的释放。</p>
<p>当释放完锁之后，就会执行<code>shouldParkAfterFailedAcquire(p, node) &amp;&amp;parkAndCheckInterrupt()</code>判断当前的线程是否应该被挂起，我们来看看它的源码实现：<br><img src="https://img-blog.csdnimg.cn/20200524123513120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"><br>在<code>shouldParkAfterFailedAcquire</code>中的实现，当前驱节点的状态量<code>waitStatus</code>为<code>SIGNAL</code>的时候，就会挂起。<br><img src="https://img-blog.csdnimg.cn/20200524123719178.png"><br>通过上面的分析对于AQS的实现基本有比较清晰的认识，主要是对实现类<code>ReentrantLock</code>的实现原理进行深入的分析，并且是基于<strong>非公平锁</strong>和<strong>独占锁</strong>的实现。</p>
<p>在AQS的底层维护了一个<strong>FIFO队列</strong>，多线程竞争共享资源的时候，<strong>失败的线程会被添加入队列中</strong>，<strong>非公平锁</strong>实现中，新加入的线程节点会<strong>自旋</strong>尝试的获取锁。</p>
<p>分析完AQS我们来分析CAS，<strong>那么什么是CAS呢？</strong></p>
<h2 id="CAS简介"><a href="#CAS简介" class="headerlink" title="CAS简介"></a>CAS简介</h2><p>在分析<code>ReentrantLock</code>的具体实现的源码中，可以看出所有涉及设置共享变量的操作，都会指向CAS操作，保证原子性操作。</p>
<p><code>CAS(compare and swap)</code>原语理解就是比较并交换的意思，<strong>CAS是一种乐观锁的实现</strong>。</p>
<p>在CAS的算法实现中有三个值：<strong>更新的变量</strong>、<strong>旧的值</strong>、<strong>新值</strong>。在修改共享资源时候，会与原值进行比较，若是等于原值，就修改为新值。</p>
<p>于是在这里的算法实现下，即使不加锁，也能保证数据的可见性，即使的发现数据是否被更改，若是数据已经被更新则写操作失败。</p>
<p>但是CAS也会引发ABA的问题，<strong>什么是ABA问题呢？</strong> 不慌请听我详细道来</p>
<h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><p>ABA问题就是假如有两个线程，同一时间读取一个共享变量<code>state=1</code>，此时两个线程都已经将state的副本赋值到自己的工作内存中。</p>
<p>当线程一对state修改<code>state=state+1</code>，并且写入到主存中，然后线程一又对<code>state=state-1</code>写入到主存，此时主存的state是变化了两次，只不过又变回了原来的值。</p>
<p>那么此时线程二修改state的时候就会修改成功，这就是ABA问题。对于<strong>ABA问题的解决方案就是加版本号（version）</strong>，每次进行比较的时候，也会比较版本号。</p>
<p>因为版本版是只增不减，比如以时间作为版本号，每一时刻的时间都不一样，这样就能避免ABA的问题。</p>
<h2 id="CAS性能分析"><a href="#CAS性能分析" class="headerlink" title="CAS性能分析"></a>CAS性能分析</h2><p>相对于<strong>synchronized的阻塞算法</strong>的实现，<strong>CAS采用的是乐观锁的非阻塞算法</strong>的实现，一般CPU在进行线程的上下文切换的时间比执行CPU的指令集的时间长，所以CAS操作在性能上也有了很大的提升。</p>
<p>但是所有的算法都是没有最完美的，在执行CAS的操作中，没有更新成功的就会自旋，这样也会消耗CPU的资源，对于CPU来说是不友好的。</p>
</div><div class="index-category-tag">  <hr></div></article></div><!--!--><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2020-10-14  <a class="commentCountImg" href="/2020/10/14/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8CCglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%80%E5%BC%BA%E7%8E%8B%E8%80%85%E9%98%B5%E5%AE%B9/#comment-container"><span class="display-none-class">d41d8cd98f00b204e9800998ecf8427e</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="d41d8cd98f00b204e9800998ecf8427e">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>24 m  <i class="fas fa-pencil-alt"> </i>3.6 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/10/14/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8CCglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%80%E5%BC%BA%E7%8E%8B%E8%80%85%E9%98%B5%E5%AE%B9/"> </a></h1><div class="content"><p><img src="https://img-blog.csdnimg.cn/20200607141226118.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70#pic_center"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇讲解了反射的知识[]，作为反射的入门级，然后这一篇主要也是讲解动态代理的实现机制。</p>
<p>动态代理包括<strong>jdk的动态代理</strong>和<strong>cglib 的动态代理</strong>，两者实现相同的功能，但是实现方式却是有明显的区别。</p>
<p>下面我们就通过代码的方式层层的深入这两种动态代理，了解他们的性能以、底层的实现原理及应用场景。</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>在详细介绍动态代理之前，先来说说Java中的代理模式。代理模式分为两种：</p>
<ol>
<li><strong>静态代理</strong>：也就是23种设计模式中的代理模式，由程序员自己编写源代码并进行编译，在程序运行之前已经编译好了.class文件。</li>
<li><strong>动态代理</strong>：包括jdk的动态代理和cglib的动态代理，运行时通过反射动态创建。</li>
</ol>
<p>代理模式定义：我的个人理解就是给某一个对象提供一个代理对象，在代理对象中拥有被代理对象的引用，并在代理对象中调用被代理对象的方法之前和之后进行方法的增强。</p>
<p>我这里画了一张代理模式的类图，设计模式中的代理模式比较简单，代理类和委托类有公共的接口，最后由代理类去执行委托类的方法：<br><img src="https://img-blog.csdnimg.cn/20200607210857959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"><br>代理模式就好像生活中的中介，去帮你做事，而不用比自己去做事。举个例子，比如你要买车，但是买车之前你要到处找车源，找到车源给钱了还要办理一堆手续。</p>
<p>（1）下面我们以买车这个案例进行代理模式的代码编写，首先要有一个公共的接口Person，Person接口里面定义公共的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Person&#123;</span><br><span class="line">    void buyCar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）然后定义一个委托类，也就是我本人Myself，并实现Person接口，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Myself implements Person &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void buyCar() &#123;</span><br><span class="line">        System.out.println(&quot;我要买车了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）最后就是创建代理类CarProxy，同样也是实现Person接口，具体实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class CarProxy implements Person&#123;</span><br><span class="line"></span><br><span class="line">    private Myself  myself ;</span><br><span class="line"></span><br><span class="line">    public CarProxy(final Myself  myself ) &#123;</span><br><span class="line">        this.myself &#x3D; myself ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void buyCar() &#123;</span><br><span class="line">        System.out.println(&quot;买车前去找车源&quot;);</span><br><span class="line">        myself .buyCar();</span><br><span class="line">        System.out.println(&quot;买车后办理手续&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代理的demo很简单，如上面的类图所示，代理类和委托类都实现公共的接口Person，在委托类中进行方法的具体业务逻辑的实现，而代理类中再次对这个方法进行增强。</p>
<p><strong>代理模式</strong>的优点就是<strong>能够对目标对象进行功能的扩展</strong>，缺点是每一个业务类都要创建一个代理类，这样会<strong>使我们系统内的类的规模变得很大，不利于维护</strong>。</p>
<p>于是就出现了动态代理，仔细思考静态代理的缺点，就是一个委托类就会对象一个代理类，那么是否可以将代理类做成一个通用的呢？</p>
<p>我们仔细来看一下下面的这个图：<br><img src="https://img-blog.csdnimg.cn/20200607220214788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"><br>我们把静态代理所有的执行过程都可以抽象成这张图的执行过程，Proxy角色无非是在<strong>调用委托类处理业务的方法之前或者之后做一些额外的操作</strong>。</p>
<p>那么为了做一个通用性的处理，就把调用委托类的method的动作抽出来，看成一个通用性的处理类，于是就有了<code>InvocationHandler</code>角色，抽象成一个处理类。</p>
<p>这样在Proxy和委托类之间就多了一个<code>InvocationHandler</code>处理类的角色，这个角色主要是<strong>将之前代理类调用委托类的方法的动作进行统一的调用，都由InvocationHandler来处理</strong>。</p>
<p>于是之前上面的类图就有了这样的改变，在Proxy和委托类之间加入了InvocationHandler，具体的实现图如下：<br><img src="https://img-blog.csdnimg.cn/20200607223136237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"><br>看完上面的图似乎有那么一点点的理解，下面我们就来详细的深入动态代理。</p>
<h2 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a>jdk动态代理</h2><p>上面讲解到动态代理是在运行时环境动态加载class文件，并创建对应的class对象，那么动态代理着静态代理的执行时机是在哪里呢？</p>
<p>我这边又画了一张原理图，感觉我为画图操碎了心，每一个点都会画一个想截图，是不是很暖。<br><img src="https://img-blog.csdnimg.cn/20200607234116416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"><br>这个是静态代理的运行原理图，静态代理在程序运行时就已经创建好了class文件，在程序启动后的某一个时机（用到class文件）就会加载class文件到内存中。</p>
<p>当在运行时期动态生成class文件并加载class文件的运行原理图如下：<br><img src="https://img-blog.csdnimg.cn/2020060723504649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"><br>在JVM运行期时遵循JVM字节码的结构和规范生成二进制文件，并加载到内存中生成对应的Class对象。这样，就完成了动态创建class文件和Class对象的功能了。</p>
<p>在jdk的动态代理中的<strong>Proxy类和委托类要求实现相同的功能</strong>，这里的相同是指<strong>他们都可以调用统一的逻辑业务方法</strong>。要实现这样的设计有以下三种方法：</p>
<ol>
<li><strong>实现同一个接口</strong>：接口里面定义公共的方法。</li>
<li><strong>继承</strong>：Proxy继承委托类，这样Proxy就有了和委托类一样的功能，或者两者都继承同一个类，把公共实现业务逻辑的方法放在父类中，这样也能实现。</li>
<li><strong>两者内部都有同一个类的引用</strong>：这个和继承有异曲同工之妙，都可以统一的调用统一的业务逻辑方法。</li>
</ol>
<p>在jdk的动态代理中，是采用第一种方法进行实现，必须有公共的接口，下面我们还是通过静态代理的案例使用动态代理来实现。</p>
<p>（1）首先创建一个公共接口Person：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Person&#123;</span><br><span class="line">    void buyCar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）然后创建接口的实现类Myself：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Myself implements Person &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void buyCar() &#123;</span><br><span class="line">        System.out.println(&quot;我要买车了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）这一步就是比较关键的，要创建一个类并实现<code>InvocationHandler</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class InvocationHandlerImpl implements InvocationHandler &#123;  </span><br><span class="line">  </span><br><span class="line">    private Person person;  </span><br><span class="line">      </span><br><span class="line">    public InvocationHandlerImpl(Person  person)&#123;  </span><br><span class="line">        this.person&#x3D;person;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    @Override  </span><br><span class="line">    public Object invoke(Object proxy, Method method,  Object[] args) throws Throwable &#123;  </span><br><span class="line">        System.out.println(&quot;买车前开始找车源。。。。&quot;);  </span><br><span class="line">        method.invoke(person, args);  </span><br><span class="line">        System.out.println(&quot;买车后办理手续。。。。&quot;);  </span><br><span class="line">        return null;  </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（4）最后一步就是进行测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        Myself myself&#x3D; new Myself();  </span><br><span class="line">        &#x2F;&#x2F; 创建代理对象，这里有三个参数，第一个是类的ClassLoader，第二个是该类的接口集合，第三个就是InvocationHandler</span><br><span class="line">        Object o &#x3D; Proxy.newProxyInstance(myself.getClass().getClassLoader(), myself.getClass().getInterfaces(), new InvocationHandlerImpl(myself));  </span><br><span class="line">        Person person&#x3D; (Person) o;  </span><br><span class="line">        person.buyCar();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体来说jdk动态代理的应用过程还是比较简单的，重要的实现理解他的底层实现过程，它的重要实现步骤就是<code>InvocationHandler</code>中 的<code>invoke</code>方法处理。</p>
<p>invoke方法才是实现方法的调用者，根据上面的参数最后才会创建代理对象<code>newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code>。</p>
<p>那么在实现jdk动态代理的过程都做了哪些工作呢？具体有以下6个步骤：</p>
<ol>
<li><strong>获取委托类也就是Myself上的所有接口</strong>。</li>
<li><strong>生成代理，生成的代理的名称也是有规律的，一般是在com.sun.proxy.$ProxyXXX</strong>。</li>
<li><strong>动态创建代理类的字节码信息，也就是class文件</strong>。</li>
<li><strong>根据class文件创建Class对象</strong>。</li>
<li><strong>创建自己的InvocationHandler并实现InvocationHandler重写invoke方法，实现对委托类方法的调用和增强</strong>。</li>
<li><strong>最后是代理对象的创建，并调用方法，实现代理的功能</strong>。</li>
</ol>
<p>我们可以通过反编译工具来看看生成的代理类的源码是怎么样的，我这里使用的反编译工具是<code>jd-gui</code>，推荐给大家。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"> public final class MyselfProxy extends Proxy  implements Person  &#123;  </span><br><span class="line">  private static Method m1;  </span><br><span class="line">  private static Method m3;  </span><br><span class="line">  private static Method m0;  </span><br><span class="line">  private static Method m2;  </span><br><span class="line">  </span><br><span class="line">  public MyselfProxy(InvocationHandler paramInvocationHandler)  throws    &#123;  </span><br><span class="line">    super(paramInvocationHandler);  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  public final boolean equals(Object paramObject)  throws    &#123;  </span><br><span class="line">    try   &#123; &#x2F;&#x2F; InvocationHandler 实现equals的调用</span><br><span class="line">      return ((Boolean)this.h.invoke(this, m1, new Object[] &#123; paramObject &#125;)).booleanValue();  </span><br><span class="line">    &#125;   catch (Error|RuntimeException localError)   &#123;  </span><br><span class="line">      throw localError;  </span><br><span class="line">    &#125;  catch (Throwable localThrowable)  &#123;  </span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  public final void buyCar()  throws  &#123;  </span><br><span class="line">    try   &#123;  </span><br><span class="line">       &#x2F;&#x2F; InvocationHandler实现buyCar的调用</span><br><span class="line">      this.h.invoke(this, m3, null);  </span><br><span class="line">      return;  </span><br><span class="line">    &#125;  catch (Error|RuntimeException localError)   &#123;  </span><br><span class="line">      throw localError;  </span><br><span class="line">    &#125;   catch (Throwable localThrowable)   &#123;  </span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  public final int hashCode()   throws    &#123;  </span><br><span class="line">    try   &#123;  </span><br><span class="line">       &#x2F;&#x2F; InvocationHandler实现hashCode方法的调用</span><br><span class="line">       return ((Integer)this.h.invoke(this, m0, null)).intValue();  </span><br><span class="line">    &#125;  </span><br><span class="line">    catch (Error|RuntimeException localError)  </span><br><span class="line">    &#123;  </span><br><span class="line">      throw localError;  </span><br><span class="line">    &#125;  </span><br><span class="line">    catch (Throwable localThrowable)  </span><br><span class="line">    &#123;  </span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  public final String toString()   throws    &#123;  </span><br><span class="line">    try   &#123;  </span><br><span class="line">       &#x2F;&#x2F; InvocationHandler实现toString的调用</span><br><span class="line">      return (String)this.h.invoke(this, m2, null);  </span><br><span class="line">    &#125;   catch (Error|RuntimeException localError)   &#123;  </span><br><span class="line">      throw localError;  </span><br><span class="line">    &#125;   catch (Throwable localThrowable)  &#123;  </span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  static   &#123;   </span><br><span class="line">  try   &#123;  &#x2F;&#x2F;在静态块中通过反射初始化函数</span><br><span class="line">      m1 &#x3D; Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] &#123; Class.forName(&quot;java.lang.Object&quot;) &#125;);  </span><br><span class="line">      m3 &#x3D; Class.forName(&quot;com.ldc.org.Person&quot;).getMethod(&quot;buyCar&quot;, new Class[0]);  </span><br><span class="line">      m0 &#x3D; Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]);  </span><br><span class="line">      m2 &#x3D; Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]);  </span><br><span class="line">      return;  </span><br><span class="line">    &#125;  catch (NoSuchMethodException localNoSuchMethodException)    &#123;  </span><br><span class="line">      throw new NoSuchMethodError(localNoSuchMethodException.getMessage());  </span><br><span class="line">    &#125;  catch (ClassNotFoundException localClassNotFoundException)    &#123;  </span><br><span class="line">      throw new NoClassDefFoundError(localClassNotFoundException.getMessage());  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面反编译的源码中可以可以看出，在<strong>静态块中直接通过反射的方式来生成Method对象</strong>，对方法的调用则是通过<code>InvocationHandler</code>对象来进行调用。</p>
<p>仔细的总结可以看出上面反编译出来的代理类有以下特征：</p>
<ol>
<li><strong>继承 java.lang.reflect.Proxy类，并实现统一的接口Person</strong>。</li>
<li><strong>所有的方法都是final修饰的</strong>。</li>
<li><strong>在代理类中都是通过InvocationHandler对象执行invoke方法的调用统一调用函数，invoke方法通过Method参数来区分是什么方法，进而相应的处理</strong>。</li>
</ol>
<p>到这里我想大家应该对jdk的动态代理有一个清晰的认识了，包括他的底层实现的原理，下面我们就来详细的了解cglib动态代理的是实现方式。</p>
<h2 id="cglib动态代理"><a href="#cglib动态代理" class="headerlink" title="cglib动态代理"></a>cglib动态代理</h2><p>在实现jdk的动态代理的实现会发现，<strong>jdk动态代理必须实现一个接口</strong>，并且代理类也<strong>只能代理接口中实现的方法</strong>，要是实现类中有自己私有的方法，而接口中没有的话，该方法不能进行代理调用。</p>
<p>基于这种情况<code>cglib</code>便出现了，他也可以在运行期扩展Java类和Java接口。</p>
<p><code>cglib</code>底层是采用<strong>字节码技术</strong>，其原理是通过字节码技术生成一个子类，并在子类中拦截父类的方法的调用，织入业务逻辑。</p>
<p>因为原理是采用继承的方式，所以被代理的类不能被final修饰，在Spring Aop中底层的实现是以这两种动态代理作为基础进行实现。</p>
<p>当使用cglib动态代理一个类demo时，JVM又做了哪些工作呢？</p>
<ol>
<li><strong>首先找到demo类中的所有非final的公共方法。</strong></li>
<li><strong>然后将这些方法转化为字节码。</strong></li>
<li><strong>通过这些字节码转化为Class对象。</strong></li>
<li><strong>最后由MethodInterceptor实现代理类中所有方法的调用。</strong></li>
</ol>
<p>（1）那么我们通过代码也来实现cglib动态代理，还是创建Myself类，但是此时不需要实现接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Myself &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void buyCar() &#123;</span><br><span class="line">        System.out.println(&quot;I&#39;m going to buy a house&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）然后是创建<code>MyMethodInterceptor</code>类实现<code>MethodInterceptor</code>接口，这个和动态代理实现<code>InvocationHandler</code>方式一样，实现统一方法的调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MyMethodInterceptor implements MethodInterceptor &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    public Object intercept(Object obj, Method method, Object[] args,  MethodProxy proxy) throws Throwable &#123;  </span><br><span class="line">        System.out.println(&quot;买车前开始找车源。。。。&quot;);  </span><br><span class="line">        proxy.invokeSuper(obj, args);  </span><br><span class="line">        System.out.println(&quot;买车后办理手续。。。。&quot;);  </span><br><span class="line">        return null;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）最后是进行测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        Myself myself&#x3D; new Myself();  </span><br><span class="line">        MyMethodInterceptor myMethodInterceptor &#x3D; new MyMethodInterceptor ();  </span><br><span class="line">        &#x2F;&#x2F;cglib 中加强器，用来创建动态代理  </span><br><span class="line">        Enhancer enhancer &#x3D; new Enhancer();    </span><br><span class="line">         &#x2F;&#x2F;设置要创建的代理类  </span><br><span class="line">        enhancer.setSuperclass(myself.getClass());    </span><br><span class="line">        &#x2F;&#x2F; 设置回调，这里相当于是对于代理类上所有方法的调用</span><br><span class="line">         enhancer.setCallback(myMethodInterceptor );  </span><br><span class="line">         &#x2F;&#x2F; 创建代理类</span><br><span class="line">         Programmer proxy &#x3D;(Myself)enhancer.create();  </span><br><span class="line">         proxy.buyCar();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结来说cglib是一个强大的、高性能的Code生产类库，在Spring中就是通过cglib方式继承要被代理的类，重写父类的方法，实现Aop编程。</p>
<p>cglib创建动态代理对象的性能时机要比jdk动态代理的方式高很多，但是创建对象所花的时间却要比jdk动态代理方式多很多。</p>
<p>在应用方面单例模式更适合用cglib，无需频繁的创建对象，相反，则使用jdk动态代理的方式更加合适。<br><img src="https://img-blog.csdnimg.cn/20200608234613699.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70#pic_center"></p>
</div><div class="index-category-tag">  <hr></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2020-10-14  <a class="commentCountImg" href="/2020/10/14/%E4%BD%A0%E8%A6%81%E7%9A%84Mysql%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%8C%E6%9D%A5%E8%87%AA%E4%BA%8E%E4%B8%80%E4%BD%8D%E5%A4%A7%E4%BD%AC%E7%9A%84%E7%AC%94%E8%AE%B0/#comment-container"><span class="display-none-class">d41d8cd98f00b204e9800998ecf8427e</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="d41d8cd98f00b204e9800998ecf8427e">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>19 m  <i class="fas fa-pencil-alt"> </i>2.8 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/10/14/%E4%BD%A0%E8%A6%81%E7%9A%84Mysql%E4%BC%98%E5%8C%96%E6%8F%90%E9%AB%98%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%8C%E6%9D%A5%E8%87%AA%E4%BA%8E%E4%B8%80%E4%BD%8D%E5%A4%A7%E4%BD%AC%E7%9A%84%E7%AC%94%E8%AE%B0/"> </a></h1><div class="content"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>对于mysql的优化是一个综合性的技术，sql的优化只是其中的一种，其中主要包括 ：</p>
<ol>
<li>表的设计合理化(符合3大范式)。</li>
<li>添加索引(index) [普通索引、主键索引、唯一索引unique、全文索引]。</li>
<li>分表技术(水平分割、垂直分割)。</li>
<li>读写[写: update/delete/add]分离。</li>
</ol>
<h2 id="合理设计表（三大范式）"><a href="#合理设计表（三大范式）" class="headerlink" title="合理设计表（三大范式）"></a>合理设计表（三大范式）</h2><p>在表的设计中一定条件下要满足三范式，表的范式，是首先符合第一范式, 才能满足第二范式 , 进一步满足第三范式。</p>
<p>第一范式: 即表的列的具有原子性,不可再分解，即列的信息，不能分解, 只有数据库是关系型数据库(mysql/oracle/db2/sql server)，就自动的满足第一范式。</p>
<p>第二范式: 表中的记录是唯一的, 就满足第二范式, 通常我们设计一个主键来实现。</p>
<p>第三范式: 即表中不要有冗余数据, 就是说，表的信息，如果能够被推导出来，就不应该单独的设计一个字段来存放. 比如下面的设计就是不满足第三范式：<br><img src="https://img-blog.csdnimg.cn/20200319224512474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"><br>表1存在冗余表2的数据，正常的设计都会设计成如下：<br><img src="https://img-blog.csdnimg.cn/2020031922462777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"><br><strong>注意：</strong> 反第三范式: 但是没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。具体做法是： 在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，允许冗余。 </p>
<p>在1对N的情况下，为了提高查询的效率，是允许部分字段冗余的。</p>
<h2 id="Sql优化"><a href="#Sql优化" class="headerlink" title="Sql优化"></a>Sql优化</h2><p>Sql的优化中，主要是对字段添加索引，主要包含有这四种索引(主键索引/唯一索引/全文索引/普通索引)</p>
<h3 id="主键索引添加"><a href="#主键索引添加" class="headerlink" title="主键索引添加"></a>主键索引添加</h3><p>当一张表，把某个列设为主键的时候，则该列就是主键索引,下面的id 列就是主键索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table user</span><br><span class="line">(id int unsigned primary key auto_increment ,</span><br><span class="line">name varchar(32) not null defaul ‘’);</span><br></pre></td></tr></table></figure>

<p>如果你创建表时，没有指定主键索引，也可以在创建表后，在添加, 指令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 add primary key (列名);</span><br><span class="line">&#x2F;&#x2F;举例</span><br><span class="line">alter table user add primary key (id);</span><br></pre></td></tr></table></figure>

<h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><p>一般来说，普通索引的创建，是先创建表，然后在创建普通索引<br>比如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table user(</span><br><span class="line">id int unsigned,</span><br><span class="line">name varchar(32)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">create index 索引名 on 表 (列1,列名2);</span><br></pre></td></tr></table></figure>

<h3 id="创建全文索引"><a href="#创建全文索引" class="headerlink" title="创建全文索引"></a>创建全文索引</h3><p>全文索引，主要是针对对文件，文本的检索, 比如文章, 全文索引针对MyISAM有用。创建如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE articles (</span><br><span class="line">       id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,</span><br><span class="line">       title VARCHAR(200),</span><br><span class="line">       body TEXT,</span><br><span class="line">       FULLTEXT (title,body)</span><br><span class="line">     )engine&#x3D;myisam charset utf8;</span><br></pre></td></tr></table></figure>
<p>如何使用全文索引:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select * from articles where body like ‘%非科班%’;  &#x2F;&#x2F;不会使用到全文索引</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 查看是否使用索引:</span><br><span class="line">explain  select * from articles where body like ‘%非科班%’</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 正确的用法是:</span><br><span class="line">select * from articles where match(title,body) against(‘非科班’); </span><br></pre></td></tr></table></figure>
<p>说明:</p>
<ol>
<li>在mysql中fulltext 索引只针对 myisam生效</li>
<li>mysql自己提供的fulltext针对英文生效-&gt;sphinx (coreseek) 技术处理中文 </li>
<li>使用方法是match(字段名..) against(‘关键字’)</li>
<li>全文索引一个 叫 停止词,  因为在一个文本中，创建索引是一个无穷大的数，因此，对一些常用词和字符，就不会创建，这些词，称为停止词.</li>
</ol>
<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>当表的某列被指定为unique约束时，这列就是一个唯一索引</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 创建</span><br><span class="line">create table user(id int primary key auto_increment , name varchar(32) unique);</span><br></pre></td></tr></table></figure>

<p>这时, name 列就是一个唯一索引，unique字段可以为NULL,并可以有多NULL, 但是如果是具体内容，则不能重复，主键字段，不能为NULL,也不能重复。</p>
<p>创建唯一索引</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table user(id int primary key auto_increment, name varchar(32));</span><br><span class="line"></span><br><span class="line">create unique index 索引名  on 表名 (列表..);</span><br></pre></td></tr></table></figure>

<p>查询索引</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">desc 表名  //不能够显示索引名</span><br><span class="line">show index(es) from 表名</span><br><span class="line">show keys from 表名</span><br></pre></td></tr></table></figure>

<p>删除索引</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 drop index 索引名; </span><br><span class="line"></span><br><span class="line">//如果删除主键索引。</span><br><span class="line">alter table 表名 drop primary key</span><br></pre></td></tr></table></figure>
<h3 id="索引使用的注意事项"><a href="#索引使用的注意事项" class="headerlink" title="索引使用的注意事项"></a>索引使用的注意事项</h3><p>由于索引本身很大，占用磁盘空间，对dml操作有影响，变慢，满足以下条件的字段，才应该创建索引。</p>
<ol>
<li>肯定在where条经常使用 </li>
<li>该字段的内容不是唯一的几个值</li>
<li>字段内容不是频繁变化</li>
</ol>
<p>explain 可以帮助我们在不真正执行某个sql语句时，就执行mysql怎样执行，这样利用我们去分析sql指令。<br><img src="https://img-blog.csdnimg.cn/20200319231552163.png"></p>
<ol>
<li>id：查询的序列号。</li>
<li>select_type：查询类型。</li>
<li>table：查询表名。</li>
<li>type：扫描方式，all表示全表扫描。</li>
<li>possible_keys：可是使用到的索引。</li>
<li>key：实际使用到的索引。</li>
<li>rows：该sql扫面了多少行。</li>
<li>Extra：sql语句额外的信息，比如排序方式</li>
</ol>
<h3 id="sql语句的小技巧"><a href="#sql语句的小技巧" class="headerlink" title="sql语句的小技巧"></a>sql语句的小技巧</h3><ol>
<li>在使用group by 分组查询是，默认分组后，还会排序，可能会降低速度，在group by 后面增加 order by null 就可以防止排序。如下图所示</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200319232047100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"></p>
<ol start="2">
<li>有些情况下，可以使用连接来替代子查询。因为使用join，MySQL不需要在内存中创建临时表。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from dept, emp <span class="built_in">where</span> dept.deptno=emp.deptno; </span><br><span class="line">// 替换成</span><br><span class="line">select * from dept left join emp on dept.deptno=emp.deptno;  </span><br></pre></td></tr></table></figure>
<h2 id="正确的选择mysql的存储引擎"><a href="#正确的选择mysql的存储引擎" class="headerlink" title="正确的选择mysql的存储引擎"></a>正确的选择mysql的存储引擎</h2><p>Myisam : 如果表对事务要求不高，同时是以查询和添加为主的，我们考虑使用myisam存储引擎. ,比如 bbs 中的 发帖表，回复表。</p>
<p>INNODB : 对事务要求高，保存的数据都是重要数据，我们建议使用INNODB,比如订单表，账号表。<br><img src="https://img-blog.csdnimg.cn/20200319232346308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"><br>如果你的数据库的存储引擎是myisam,请一定记住要定时进行碎片整理</p>
<h2 id="分表技术"><a href="#分表技术" class="headerlink" title="分表技术"></a>分表技术</h2><blockquote>
<p><strong>为什么要分表？</strong><br>（1） 如果一个表的每条记录的内容很大，那么就需要更多的IO操作，如果字段值比较大，而使用频率相对比较低，可以将大字段移到另一张表中，当查询不查大字段的时候，这样就减少了I/O操作<br>（2）如果表的数据量非常非常大，那么查询就变的比较慢；也就是表的数据量影响这查询的性能。<br> （3）表中的数据本来就有独立性，例如分别记录各个地区的数据或者不同时期的数据，特别是有些数据常用，而另外一些数据不常用。<br>  （4）  分表技术有(水平分割和垂直分割)</p>
</blockquote>
<h3 id="垂直分割"><a href="#垂直分割" class="headerlink" title="垂直分割"></a>垂直分割</h3><p>垂直分割是指数据表列的拆分，把一张列比较多的表拆分为多张表。 垂直分割一般用于拆分大字段和访问频率低的字段，分离冷热数据。</p>
<p>垂直分割比较常见：例如博客系统中的文章表，比如文章tbl_articles<br>(id, titile, summary, content, user_id, create_time)，因为文章中的内容content会比较长，放在tbl_articles中会严重影响表的查询速度，所以将内容放到tbl_articles_detail(article_id, content)，像文章列表只需要查询tbl_articles中的字段即可。</p>
<p>垂直拆分的优点： 可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。</p>
<p>垂直拆分的缺点： 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂。</p>
<h3 id="水平分割"><a href="#水平分割" class="headerlink" title="水平分割"></a>水平分割</h3><p>水平拆分是指数据表行数据的拆分，表的行数超过500万行或者单表容量超过10GB时，查询就会变慢，这时可以把一张的表的数据拆成多张表来存放。水平分表尽可能使每张表的数据量相当，比较均匀。</p>
<p>水平拆分会给应用增加复杂度，它通常在查询是需要多个表名，查询所有数据需要union操作。在许多数据库应用中，这种复杂性会超过它带来的优点。</p>
<p>因为只要索引关键字不大，则在索引用于查询时，表中增加2-3倍数据量，查询时也就增加读一个索引层的磁盘次数，所以水平拆分要考虑数据量的增长速度，根据实际情况决定是否需要对表进行水平拆分。</p>
<p>水平分割最重要的是找到分割的标准，不同的表应根据业务找出不同的标准</p>
<ol>
<li>用户表可以根据用户的手机号段进行分割如user183、user150、user153、user189等，每个号段就是一张表</li>
<li>用户表也可以根据用户的id进行分割，加入分3张表user0,user1,user2，如果用户的id%3=0就查询user0表，<br>如果用户的id%3=1就查询user1表</li>
<li>对于订单表可以按照订单的时间进行分表</li>
</ol>
<h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>实现MySQL读写分离的前提是我们已经将MySQL主从复制配置完毕，读写分离实现方式：<br>（1）配置多数据源。<br>（2）使用mysql的proxy中间件代理工具。</p>
<h3 id="主从复制的原理"><a href="#主从复制的原理" class="headerlink" title="主从复制的原理"></a>主从复制的原理</h3><p>MySQL的主从复制和读写分离两者有着紧密的联系，首先要部署主从复制，只有主从复制完成了才能在此基础上进行数据的读写分离。</p>
<p><img src="https://img-blog.csdnimg.cn/20200319234614538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"></p>
<h3 id="读写分离的原理"><a href="#读写分离的原理" class="headerlink" title="读写分离的原理"></a>读写分离的原理</h3><p>读写分离就是只在主服务器上写，只在从服务器上读。基本原理是让主数据库处理事务性查询，而从服务器处理select查询。数据库复制被用来把事务性查询导致的变更同步到从数据库中。</p>
</div><div class="index-category-tag">  <hr></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2020-10-14  <a class="commentCountImg" href="/2020/10/14/%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%90%AC%E8%AF%B4%E4%BD%A0sql%E5%86%99%E7%9A%84%E6%8C%BA%E6%BA%9C%E7%9A%84%EF%BC%8C%E4%BD%A0%E8%AF%B4%E4%B8%80%E8%AF%B4%E6%9F%A5%E8%AF%A2sql%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E3%80%82/#comment-container"><span class="display-none-class">d41d8cd98f00b204e9800998ecf8427e</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="d41d8cd98f00b204e9800998ecf8427e">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>13 m  <i class="fas fa-pencil-alt"> </i>2.0 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/10/14/%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E5%90%AC%E8%AF%B4%E4%BD%A0sql%E5%86%99%E7%9A%84%E6%8C%BA%E6%BA%9C%E7%9A%84%EF%BC%8C%E4%BD%A0%E8%AF%B4%E4%B8%80%E8%AF%B4%E6%9F%A5%E8%AF%A2sql%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E3%80%82/"> </a></h1><div class="content"><p>当希望Mysql能够高效的执行的时候，最好的办法就是清楚的了解Mysql是如何执行查询的，只有更加全面的了解SQL执行的每一个过程，才能更好的进行SQl的优化。</p>
<p>当执行一条查询的SQl的时候大概发生了一下的步骤：</p>
<ol>
<li>客户端发送查询语句给服务器。</li>
<li>服务器首先检查缓存中是否存在该查询，若存在，返回缓存中存在的结果。若是不存在就进行下一步。</li>
<li>服务器进行SQl的解析、语法检测和预处理，再由优化器生成对应的执行计划。</li>
<li>Mysql的执行器根据优化器生成的执行计划执行，调用存储引擎的接口进行查询。</li>
<li>服务器将查询的结果返回客户端。</li>
</ol>
<h2 id="Mysql的执行的流程"><a href="#Mysql的执行的流程" class="headerlink" title="Mysql的执行的流程"></a>Mysql的执行的流程</h2><p>Mysql的执行的流程图如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200330211824877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"><br>这里以一个实例进行说明Mysql的的执行过程，新建一个User表，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 新建一个表</span><br><span class="line">DROP TABLE IF EXISTS User;</span><br><span class="line">CREATE TABLE &#96;User&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;name&#96; varchar(10) DEFAULT NULL,</span><br><span class="line">  &#96;age&#96; int DEFAULT 0,</span><br><span class="line">  &#96;address&#96; varchar(255) DEFAULT NULL,</span><br><span class="line">  &#96;phone&#96; varchar(255) DEFAULT NULL,</span><br><span class="line">  &#96;dept&#96; int,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;40 DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 并初始化数据，如下</span><br><span class="line">INSERT INTO User(name,age,address,phone,dept)VALUES(&#39;张三&#39;,24,&#39;北京&#39;,&#39;13265543552&#39;,2);</span><br><span class="line">INSERT INTO User(name,age,address,phone,dept)VALUES(&#39;张三三&#39;,20,&#39;北京&#39;,&#39;13265543557&#39;,2);</span><br><span class="line">INSERT INTO User(name,age,address,phone,dept)VALUES(&#39;李四&#39;,23,&#39;上海&#39;,&#39;13265543553&#39;,2);</span><br><span class="line">INSERT INTO User(name,age,address,phone,dept)VALUES(&#39;李四四&#39;,21,&#39;上海&#39;,&#39;13265543556&#39;,2);</span><br><span class="line">INSERT INTO User(name,age,address,phone,dept)VALUES(&#39;王五&#39;,27,&#39;广州&#39;,&#39;13265543558&#39;,3);</span><br><span class="line">INSERT INTO User(name,age,address,phone,dept)VALUES(&#39;王五五&#39;,26,&#39;广州&#39;,&#39;13265543559&#39;,3);</span><br><span class="line">INSERT INTO User(name,age,address,phone,dept)VALUES(&#39;赵六&#39;,25,&#39;深圳&#39;,&#39;13265543550&#39;,3);</span><br><span class="line">INSERT INTO User(name,age,address,phone,dept)VALUES(&#39;赵六六&#39;,28,&#39;广州&#39;,&#39;13265543561&#39;,3);</span><br><span class="line">INSERT INTO User(name,age,address,phone,dept)VALUES(&#39;七七&#39;,29,&#39;广州&#39;,&#39;13265543562&#39;,4);</span><br><span class="line">INSERT INTO User(name,age,address,phone,dept)VALUES(&#39;八八&#39;,23,&#39;广州&#39;,&#39;13265543563&#39;,4);</span><br><span class="line">INSERT INTO User(name,age,address,phone,dept)VALUES(&#39;九九&#39;,24,&#39;广州&#39;,&#39;13265543564&#39;,4);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在针对这个表发出一条SQl查询：<code>查询每个部门中25岁以下的员工个数大于3的员工个数和部门编号，并按照人工个数降序排序和部门编号升序排序的前两个部门。</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT dept,COUNT(phone) AS num FROM User WHERE age&lt; 25 GROUP BY dept HAVING num &gt;&#x3D; 3 ORDER BY num DESC,dept ASC LIMIT 0,2;</span><br></pre></td></tr></table></figure>

<h2 id="执行连接器"><a href="#执行连接器" class="headerlink" title="执行连接器"></a>执行连接器</h2><p>开始执行这条sql时，会检查该语句是否有权限，若是没有权限就直接返回错误信息，有权限会进行下一步，校验权限的这一步是在图一的连接器进行的，对连接用户权限的校验。</p>
<h2 id="执行检索内存"><a href="#执行检索内存" class="headerlink" title="执行检索内存"></a>执行检索内存</h2><p>相连建立之后，履行查询语句的时候，会先行检索内存，Mysql会先行冗余这个sql与否履行过，以此<code>Key-Value</code>的形式平缓适用内存中，Key是<code>检索预定</code>，Value是<code>结果集</code>。</p>
<p>假如内存key遭击中，便会间接回到给客户端，假如没命中，便会履行后续的操作，完工之后亦会将结果内存上去，当下一次进行查询的时候也是如此的循环操作。</p>
<h2 id="执行分析器"><a href="#执行分析器" class="headerlink" title="执行分析器"></a>执行分析器</h2><p>分析器主要有两步：（1）<code>词法分析</code>（2）<code>语法分析</code></p>
<p>词法分析主要执行<code>提炼关键性字</code>，比如select，<code>提交检索的表</code>，<code>提交字段名</code>，<code>提交检索条件</code>。语法分析主要执行辨别你<code>输出的sql与否准确</code>，是否<code>合乎mysql的语法</code>。</p>
<p>当Mysql没有命中内存的时候，接着执行的是 FROM student 负责把数据库的表文件加载到内存中去，<code>WHERE age&lt; 60</code>，会把所示表中的数据进行过滤，取出符合条件的记录行，生成一张临时表，如下图所示。<br><img src="https://img-blog.csdnimg.cn/20200330213710187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"><br><code>GROUP BY dept</code> 会把上图的临时表分成若干临时表，切分的过程如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200330214252626.png"><br><img src="https://img-blog.csdnimg.cn/20200330214316713.png"><br>查询的结果只有部门2和部门3才有符合条件的值，生成如上两图的临时表。接着执行<code>SELECT后面的字段</code>，SELECT后面可以是<code>表字段</code>也可以是<code>聚合函数</code>。</p>
<p>这里SELECT的情况与是否存在<code>GROUP BY</code>有关，若是不存在Mysql直接按照上图内存中整列读取。若是存在分别SELECT临时表的数据。</p>
<p>最后生成的临时表如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200330215715536.png"><br>紧接着执行<code>HAVING num&gt;2</code>过滤员工数小于等于2的部门，对于<code>WHERE</code>和<code>HAVING</code>都是进行过滤，那么这两者有什么不同呢？</p>
<p>第一点是WHERE后面只能对表字段进行过滤，不能使用聚合函数，而HAVING可以过滤表字段也可以使用聚合函数进行过滤。</p>
<p>第二点是WHERE是对执行from USer操作后，加载表数据到内存后，WHERE是对<code>原生表的字段</code>进行过滤，而HAVING是对<code>SELECT后的字段进行过滤</code>，也就是WHERE<code>不能使用别名进行过滤</code>。</p>
<p>因为执行WHERE的时候，还没有SELECT，还没有给字段赋予别名。接着生成的临时表如下图所示：<br><img src="https://img-blog.csdnimg.cn/2020033022062543.png"><br>最后在执行<code>ORDER BY后面的排序</code>以及<code>limit0,2</code>取得前两个数据，因为这里数据比较少，没有体现出来。最后生成得结果也是如上图所示。接着判断这个sql语句<code>是否有语法错误</code>，<code>关键性词与否准确</code>等等。</p>
<h2 id="执行优化器"><a href="#执行优化器" class="headerlink" title="执行优化器"></a>执行优化器</h2><p>查询优化器会将解析树转化成执行计划。一条查询可以有多种执行方法，最后都是返回相同结果。优化器的作用就是找到这其中<code>最好的执行计划</code>。</p>
<p>生成执行计划的过程会消耗较多的时间，特别是存在许多可选的执行计划时。如果在一条SQL语句执行的过程中将该语句对应的最终执行计划进行缓存。</p>
<p>当<code>相似的语句</code>再次被输入服务器时，就可以直接<code>使用已缓存的执行计划</code>，从而跳过SQL语句生成执行计划的整个过程，进而可以提高语句的执行速度。</p>
<p><img src="https://img-blog.csdnimg.cn/2020033022230581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"><br>MySQL使用基于成本的查询优化器。它会尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最少的一个。</p>
<h2 id="执行执行器"><a href="#执行执行器" class="headerlink" title="执行执行器"></a>执行执行器</h2><p>由优化器生成得执行计划，交由执行器进行执行，执行器调用存储引擎得接口，存储引擎获取数据并返回，结束整个查询得过程。</p>
<p>这里之讲解了select的过程，对于update这些修改数据或者删除数据的操作，会涉及到事务，会使用两个日志模块，redo log和binlog日志。具体对这两个日志的介绍请看着一篇文章。</p>
<p>以前的Mysql的默认存储引擎MyISAM引擎是没redo log的，而现在的默认存储引擎InnoDB引擎便是透过redo 复杂度来拥护事务的，保证事务能够准确的回滚或者提交，保证事务的ACID。</p>
<p><img src="https://img-blog.csdnimg.cn/2020033022343011.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70#pic_center"></p>
</div><div class="index-category-tag">  <hr></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2020-10-14  <a class="commentCountImg" href="/2020/10/14/%E3%80%90%E8%BF%9B%E5%A4%A7%E5%8E%82%E7%B3%BB%E5%88%97%E3%80%91Redis%E7%BC%93%E5%AD%98%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98/#comment-container"><span class="display-none-class">d41d8cd98f00b204e9800998ecf8427e</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="d41d8cd98f00b204e9800998ecf8427e">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>29 m  <i class="fas fa-pencil-alt"> </i>4.4 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/10/14/%E3%80%90%E8%BF%9B%E5%A4%A7%E5%8E%82%E7%B3%BB%E5%88%97%E3%80%91Redis%E7%BC%93%E5%AD%98%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98/"> </a></h1><div class="content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>日常的开发中，无不都是使用数据库来进行数据的存储，由于一般的系统任务中通常不会存在高并发的情况，所以这样看起来并没有什么问题。</p>
<p>一旦涉及大数据量的需求，如一些<strong>商品抢购</strong>的情景，或者<strong>主页访问量</strong>瞬间较大的时候，单一使用数据库来保存数据的系统会因为<strong>面向磁盘</strong>，<strong>磁盘读/写</strong>速度问题有严重的性能弊端，详细的<strong>磁盘读写原理</strong>请参考这一片[]。</p>
<p>在这一瞬间成千上万的请求到来，需要系统在<strong>极短的时间</strong>内完成成<strong>千上万</strong>次的<strong>读/写操作</strong>，这个时候往往不是数据库能够承受的，极其容易造成数据库系统瘫痪，最终导致服务宕机的严重生产问题。</p>
<p>为了克服上述的问题，项目通常会引入<strong>NoSQL</strong>技术，这是一种<strong>基于内存</strong>的<strong>数据库</strong>，并且提供一定的<strong>持久化</strong>功能。</p>
<p><code>Redis</code>技术就是<code>NoSQL</code>技术中的一种。<code>Redis</code>缓存的使用，极大的提升了应用程序的性能和效率，特别是<strong>数据查询</strong>方面。</p>
<p>但同时，它也带来了一些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对<strong>数据的一致性</strong>要求很高，那么就不能使用<strong>缓存</strong>。</p>
<p>另外的一些典型问题就是，<strong>缓存穿透</strong>、<strong>缓存击穿</strong>和<strong>缓存雪崩</strong>。本篇文章从实际代码操作，来提出解决这三个缓存问题的方案，毕竟Redis的缓存问题是实际面试中高频问点，理论和实操要兼得。</p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是指查询一条数据库和缓存都没有的一条数据，就会一直查询数据库，对数据库的访问压力就会增大，缓存穿透的解决方案，有以下两种：</p>
<ol>
<li><strong>缓存空对象</strong>：代码维护较简单，但是效果不好。</li>
<li><strong>布隆过滤器</strong>：代码维护复杂，效果很好。</li>
</ol>
<h3 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h3><p>缓存空对象是指当一个请求过来缓存中和数据库中都不存在该请求的数据，第一次请求就会跳过缓存进行数据库的访问，并且访问数据库后返回为空，此时也将该空对象进行缓存。</p>
<p>若是再次进行访问该空对象的时候，就会直接<strong>击中缓存</strong>，而不是再次<strong>数据库</strong>，缓存空对象实现的原理图如下：<br><img src="https://img-blog.csdnimg.cn/20200411100759260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"><br>缓存空对象的实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class UserServiceImpl &#123;</span><br><span class="line">     @Autowired</span><br><span class="line">     UserDAO userDAO;</span><br><span class="line">     @Autowired</span><br><span class="line">     RedisCache redisCache;</span><br><span class="line"> </span><br><span class="line">     public User findUser(Integer id) &#123;</span><br><span class="line">          Object object &#x3D; redisCache.get(Integer.toString(id));</span><br><span class="line">          &#x2F;&#x2F; 缓存中存在，直接返回</span><br><span class="line">          if(object !&#x3D; null) &#123;</span><br><span class="line">               &#x2F;&#x2F; 检验该对象是否为缓存空对象，是则直接返回null</span><br><span class="line">               if(object instanceof NullValueResultDO) &#123;</span><br><span class="line">                    return null;</span><br><span class="line">               &#125;</span><br><span class="line">               return (User)object;</span><br><span class="line">          &#125; else &#123;  </span><br><span class="line">               &#x2F;&#x2F; 缓存中不存在，查询数据库</span><br><span class="line">               User user &#x3D; userDAO.getUser(id);</span><br><span class="line">               &#x2F;&#x2F; 存入缓存</span><br><span class="line">               if(user !&#x3D; null) &#123;</span><br><span class="line">                    redisCache.put(Integer.toString(id),user);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F; 将空对象存进缓存</span><br><span class="line">                    redisCache.put(Integer.toString(id), new NullValueResultDO());</span><br><span class="line">               &#125;</span><br><span class="line">               return user;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缓存空对象的实现代码很简单，但是缓存空对象会带来比较大的问题，就是缓存中会存在很多空对象，占用<strong>内存的空间</strong>，浪费资源，一个解决的办法就是设置空对象的<strong>较短的过期时间</strong>，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 再缓存的时候，添加多一个该空对象的过期时间60秒</span><br><span class="line">redisCache.put(Integer.toString(id), new NullValueResultDO(),60);</span><br></pre></td></tr></table></figure>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>布隆过滤器是一种基于<strong>概率</strong>的<strong>数据结构</strong>，主要用来判断某个元素是否在集合内，它具有<strong>运行速度快</strong>（时间效率），<strong>占用内存小</strong>的优点（空间效率），但是有一定的<strong>误识别率</strong>和<strong>删除困难</strong>的问题。它只能告诉你某个元素一定不在集合内或可能在集合内。</p>
<p>在计算机科学中有一种思想：<strong>空间换时间，时间换空间</strong>。一般两者是不可兼得，而布隆过滤器运行效率和空间大小都兼得，它是怎么做到的呢？</p>
<p>在布隆过滤器中引用了一个<strong>误判率</strong>的概念，即它可能会把不属于这个集合的元素认为可能属于这个集合，但是不会把属于这个集合的认为不属于这个集合，布隆过滤器的特点如下：</p>
<ol>
<li>一个非常大<strong>的二进制位数组</strong> （数组里只有0和1）</li>
<li>若干个<strong>哈希函数</strong></li>
<li><strong>空间效率</strong>和<strong>查询效率高</strong></li>
<li>不存在<strong>漏报</strong>（False Negative）：某个元素在某个集合中，肯定能报出来。</li>
<li>可能存在<strong>误报</strong>（False Positive）：某个元素不在某个集合中，可能也被爆出来。</li>
<li>不提供删除方法，代码维护困难。</li>
<li>位数组初始化都为0，它不存元素的具体值，当元素经过哈希函数哈希后的值（也就是数组下标）对应的数组位置值改为1。</li>
</ol>
<p>实际布隆过滤器存储数据和查询数据的原理图如下：<br><img src="https://img-blog.csdnimg.cn/20200411110041782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"><br>可能很多读者看完上面的特点和原理图，还是看不懂，别急下面通过图解一步一步的讲解布隆过滤器，总而言之一句简单的话概括就是布隆过滤器是一个<strong>很大二进制</strong>的<strong>位数组</strong>，数组里面<strong>只存0和1</strong>。</p>
<p>初始化的布隆过滤器的结构图如下：<br><img src="https://img-blog.csdnimg.cn/20200411110343825.png"><br>以上只是画了布隆过滤器的很小很小的一部分，实际布隆过滤器是非常大的数组（这里的大是指它的<strong>长度大</strong>，并不是指它所占的<strong>内存空间大</strong>）。</p>
<p><strong>那么一个数据是怎么存进布隆过滤器的呢？</strong></p>
<p>当一个数据进行存入布隆过滤器的时候，会经过如干个哈希函数进行哈希（若是对哈希函数还不懂的请参考这一片[]），得到对应的哈希值作为数组的下标，然后将初始化的位数组对应的下标的值修改为1，结果图如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200411110444296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"><br>当再次进行存入第二个值的时候，修改后的结果的原理图如下：<br><img src="https://img-blog.csdnimg.cn/20200411110640460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"><br>所以每次存入一个数据，就会哈希函数的计算，计算的结果就会作为下标，在布隆过滤器中有多少个哈希函数就会计算出多少个下标，布隆过滤器插入的流程如下：</p>
<ol>
<li>将要添加的元素给m个哈希函数</li>
<li>得到对应于位数组上的m个位置</li>
<li>将这m个位置设为1</li>
</ol>
<p><strong>那么为什么会有误判率呢？</strong></p>
<p>假设在我们多次存入值后，在布隆过滤器中存在x、y、z这三个值，布隆过滤器的存储结构图如下所示：<br><img src="https://img-blog.csdnimg.cn/20200411111551119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"><br>当我们要查询的时候，比如查询a这个数，实际中a这个数是不存在布隆过滤器中的，经过2哥哈希函数计算后得到a的哈希值分别为2和13，结构原理图如下：<br><img src="https://img-blog.csdnimg.cn/20200411112038115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"><br>经过查询后，发现2和13位置所存储的值都为1，但是2和13的下标分别是x和z经过计算后的下标位置的修改，该布隆过滤器中实际不存在a，那么布隆过滤器就会误判改值可能存在，因为布隆过滤器不存<strong>元素值</strong>，所以存在<strong>误判率</strong>。</p>
<p>那么具体布隆过布隆过滤的判断的准确率和一下<strong>两个因素</strong>有关：</p>
<ol>
<li><strong>布隆过滤器大小</strong>：越大，误判率就越小，所以说布隆过滤器一般长度都是非常大的。</li>
<li><strong>哈希函数的个数</strong>：哈希函数的个数越多，那么误判率就越小。</li>
</ol>
<p><strong>那么为什么不能删除元素呢？</strong></p>
<p>原因很简单，因为删除元素后，将对应元素的下标设置为零，可能别的元素的下标也引用改下标，这样别的元素的判断就会收到影响，原理图如下：<br><img src="https://img-blog.csdnimg.cn/20200411113051903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"><br>当你删除z元素之后，将对应的下标10和13设置为0，这样导致x和y元素的下标受到影响，导致数据的判断不准确，所以直接不提供删除元素的api。</p>
<p>以上说的都是布隆过滤器的原理，只有理解了原理，在实际的运用才能如鱼得水，下面就来实操代码，手写一个简单的布隆过滤器。</p>
<p>对于要手写一个布隆过滤器，首先要明确布隆过滤器的核心：</p>
<ul>
<li>若干哈希函数</li>
<li>存值得Api</li>
<li>判断值得Api</li>
</ul>
<p>实现得代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class MyBloomFilter &#123;</span><br><span class="line">    &#x2F;&#x2F; 布隆过滤器长度</span><br><span class="line">    private static final int SIZE &#x3D; 2 &lt;&lt; 10;</span><br><span class="line">    &#x2F;&#x2F; 模拟实现不同的哈希函数</span><br><span class="line">    private static final int[] num&#x3D; new int[] &#123;5, 19, 23, 31,47, 71&#125;;   </span><br><span class="line">    &#x2F;&#x2F; 初始化位数组</span><br><span class="line">    private BitSet bits &#x3D; new BitSet(SIZE);</span><br><span class="line">    &#x2F;&#x2F; 用于存储哈希函数</span><br><span class="line">    private MyHash[] function &#x3D; new MyHash[num.length];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 初始化哈希函数</span><br><span class="line">    public MyBloomFilter() &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; num.length; i++) &#123;</span><br><span class="line">            function [i] &#x3D; new MyHash(SIZE, num[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    &#x2F;&#x2F; 存值Api </span><br><span class="line">    public void add(String value) &#123;</span><br><span class="line">        &#x2F;&#x2F; 对存入得值进行哈希计算</span><br><span class="line">        for (MyHash f: function) &#123;</span><br><span class="line">            &#x2F;&#x2F; 将为数组对应的哈希下标得位置得值改为1</span><br><span class="line">            bits.set(f.hash(value), true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    &#x2F;&#x2F; 判断是否存在该值得Api </span><br><span class="line">    public boolean contains(String value) &#123;</span><br><span class="line">        if (value &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        boolean result&#x3D; true;</span><br><span class="line">        for (MyHash f : func) &#123;</span><br><span class="line">            result&#x3D; result&amp;&amp; bits.get(f.hash(value));</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哈希函数代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static class MyHash &#123;</span><br><span class="line">        private int cap;</span><br><span class="line">        private int seed;</span><br><span class="line">        &#x2F;&#x2F; 初始化数据</span><br><span class="line">        public MyHash(int cap, int seed) &#123;</span><br><span class="line">            this.cap &#x3D; cap;</span><br><span class="line">            this.seed &#x3D; seed;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 哈希函数</span><br><span class="line">        public int hash(String value) &#123;</span><br><span class="line">            int result &#x3D; 0;</span><br><span class="line">            int len &#x3D; value.length();</span><br><span class="line">            for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">                result &#x3D; seed * result + value.charAt(i);</span><br><span class="line">            &#125;</span><br><span class="line">            return (cap - 1) &amp; result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>布隆过滤器测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void test &#123;</span><br><span class="line">    String value &#x3D; &quot;4243212355312&quot;;</span><br><span class="line">    MyBloomFilter filter &#x3D; new MyBloomFilter();</span><br><span class="line">    System.out.println(filter.contains(value));</span><br><span class="line">    filter.add(value);</span><br><span class="line">    System.out.println(filter.contains(value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是手写了一个非常简单得布隆过滤器，但是实际项目中可能事由牛人或者大公司已经帮你写好的，如谷歌的<code>Google Guava</code>，只需要在项目中引入一下依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.guava&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;guava&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;27.0.1-jre&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<p>实际项目中具体的操作代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void MyBloomFilterSysConfig &#123;</span><br><span class="line"></span><br><span class="line">     @Autowired</span><br><span class="line">     OrderMapper orderMapper</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F; 1.创建布隆过滤器  第二个参数为预期数据量10000000，第三个参数为错误率0.00001</span><br><span class="line">    BloomFilter&lt;CharSequence&gt; bloomFilter &#x3D;  BloomFilter.create(Funnels.stringFunnel(Charset.forName(&quot;utf-8&quot;)),10000000, 0.00001);</span><br><span class="line">    &#x2F;&#x2F; 2.获取所有的订单，并将订单的id放进布隆过滤器里面</span><br><span class="line">    List&lt;Order&gt; orderList &#x3D; orderMapper.findAll()</span><br><span class="line">    for (Order order;orderList ) &#123;</span><br><span class="line">        Long id &#x3D; order.getId();</span><br><span class="line">        bloomFilter.put(&quot;&quot; + id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实际项目中会启动一个<strong>系统任务</strong>或者<strong>定时任务</strong>，来初始化布隆过滤器，将热点查询数据的id放进布隆过滤器里面，当用户再次请求的时候，使用布隆过滤器进行判断，改订单的id是否在布隆过滤器中存在，不存在直接返回null，具体操作代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 判断订单id是否在布隆过滤器中存在</span><br><span class="line">bloomFilter.mightContain(&quot;&quot; + id)</span><br></pre></td></tr></table></figure>
<p>布隆过滤器的缺点就是要维持容器中的数据，因为订单数据肯定是频繁变化的，实时的要更新布隆过滤器中的数据为最新。</p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p><strong>缓存击穿</strong>是指一个<code>key</code>非常热点，在不停的扛着大并发，<strong>大并发</strong>集中对这一个点进行访问，当这个key在失效的瞬间，持续的<strong>大并发</strong>就穿破缓存，直接请求数据库，瞬间对数据库的访问压力增大。</p>
<p>缓存击穿这里强调的是<strong>并发</strong>，造成缓存击穿的原因有以下两个：</p>
<ol>
<li>该数据没有人查询过 ，第一次就大并发的访问。（冷门数据）</li>
<li>添加到了缓存，reids有设置数据失效的时间 ，这条数据刚好失效，大并发访问（热点数据）</li>
</ol>
<p>对于缓存击穿的解决方案就是加锁，具体实现的原理图如下：<br><img src="https://img-blog.csdnimg.cn/20200411153315173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"><br>当用户出现<strong>大并发</strong>访问的时候，在查询缓存的时候和查询数据库的过程加锁，只能第一个进来的请求进行执行，当第一个请求把该数据放进缓存中，接下来的访问就会直接集中缓存，防止了<strong>缓存击穿</strong>。</p>
<p>业界比价普遍的一种做法，即根据key获取value值为空时，锁上，从数据库中<code>load</code>数据后再释放锁。若其它线程获取锁失败，则等待一段时间后重试。这里要注意，分布式环境中要使用<strong>分布式锁</strong>，<strong>单机</strong>的话用普通的锁（<code>synchronized</code>、<code>Lock</code>）就够了。</p>
<p>下面以一个获取商品库存的案例进行代码的演示，<strong>单机版</strong>的锁实现具体实现的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取库存数量</span><br><span class="line">public String getProduceNum(String key) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        synchronized (this) &#123;   &#x2F;&#x2F;加锁</span><br><span class="line">            &#x2F;&#x2F; 缓存中取数据，并存入缓存中</span><br><span class="line">            int num&#x3D; Integer.parseInt(redisTemplate.opsForValue().get(key));</span><br><span class="line">            </span><br><span class="line">            if (num&gt; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F;没查一次库存-1</span><br><span class="line">                redisTemplate.opsForValue().set(key, (num- 1) + &quot;&quot;);</span><br><span class="line">                System.out.println(&quot;剩余的库存为num：&quot; + (num- 1));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                System.out.println(&quot;库存为0&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot;OK&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>分布式</strong>的锁实现具体实现的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public String getProduceNum(String key) &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取分布式锁</span><br><span class="line">    RLock lock &#x3D; redissonClient.getLock(key);</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取库存数</span><br><span class="line">        int num&#x3D; Integer.parseInt(redisTemplate.opsForValue().get(key));  </span><br><span class="line">        &#x2F;&#x2F; 上锁           </span><br><span class="line">        lock.lock();</span><br><span class="line">        if (num&gt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F;减少库存，并存入缓存中</span><br><span class="line">            redisTemplate.opsForValue().set(key, (num - 1) + &quot;&quot;);</span><br><span class="line">            System.out.println(&quot;剩余库存为num：&quot; + (num- 1));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;库存已经为0&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        &#x2F;&#x2F;解锁</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot;OK&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩 是指在某一个时间段，缓存集中过期失效。此刻无数的请求直接绕开缓存，直接请求数据库。</p>
<p>造成缓存雪崩的原因，有以下两种：</p>
<ol>
<li>reids宕机</li>
<li>大部分数据失效</li>
</ol>
<p>比如天猫双11，马上就要到双11零点，很快就会迎来一波抢购，这波商品在23点集中的放入了缓存，假设缓存一个小时，那么到了凌晨24点的时候，这批商品的缓存就都过期了。</p>
<p>而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰，对数据库造成压力，甚至压垮数据库。</p>
<p>缓存雪崩的原理图如下，当正常的情况下，key没有大量失效的用户访问原理图如下：<br><img src="https://img-blog.csdnimg.cn/20200411160745295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"><br>当某一时间点，key大量失效，造成的缓存雪崩的原理图如下：<br><img src="https://img-blog.csdnimg.cn/20200411161306232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70"><br>对于缓存雪崩的解决方案有以下两种：</p>
<ol>
<li>搭建高可用的集群，防止单机的redis宕机。</li>
<li>设置不同的过期时间，防止同意之间内大量的key失效。</li>
</ol>
<blockquote>
<p>针对业务系统，永远都是具体情况具体分析，没有最好，只有最合适。于缓存其它问题，缓存满了和数据丢失等问题，我们后面继续深入的学习。最后也提一下三个词LRU、RDB、AOF，通常我们采用LRU策略处理溢出，Redis的RDB和AOF持久化策略来保证一定情况下的数据安全。</p>
</blockquote>
</div><div class="index-category-tag">  <hr></div></article></div><!--!--><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/page/0/">Previous</a></div><div class="pagination-next"><a href="/page/2/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://pic1.zhimg.com/v2-bfd9b8d48b2d2ef0bcd80d2cc4cc6604_xl.jpg" alt="黎杜"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">黎杜</p><p class="is-size-6 is-block">一个钻研技术和热爱分享的博主</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>广东.广州</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">14</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Weibo" href="https://weibo.com/u/2084518621?is_all=1"><i class="fab fa-weibo"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="/730500468@qq.com"><i class="fa fa-envelope"></i></a></div><div><hr><p id="hitokoto">:D 一言句子获取中...</p><script type="text/javascript" defer>function getYiyan(){
                                $.getJSON("https://v1.hitokoto.cn/", function (data) {
                                if(data){
                                    $('#hitokoto').html("");
                                    $('#hitokoto').append("<strong style='color: #3273dc;'>"+data.hitokoto+"</strong>"+
                                    "<p>"+"From《"+data.from+"》</p><p>Provider-"+data.creator+"</p>");
                                }});}
                                $(function (){getYiyan();$('#hitokoto').click(function(){getYiyan();})});</script></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget"><div class="card-content"><h3 class="menu-label">Latest Comment</h3><span class="body_hot_comment">Loading...Wait a Minute!</span></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-10-14T10:04:30.012Z">2020-10-14</time></p><p class="title"><a href="/2020/10/14/JAVA%20%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E5%AE%8C%E6%95%B4%E5%A5%97%E8%B7%AF%EF%BC%8C%E4%BB%8E%20CPU%E3%80%81%E7%A3%81%E7%9B%98%E3%80%81%E5%86%85%E5%AD%98%E3%80%81%E7%BD%91%E7%BB%9C%E3%80%81GC%20%E4%B8%80%E6%9D%A1%E9%BE%99%EF%BC%81/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-10-14T10:04:20.188Z">2020-10-14</time></p><p class="title"><a href="/2020/10/14/%E5%9B%BE%E7%89%87%E5%AD%98%E5%82%A8%E6%96%B9%E6%A1%88%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B-%E4%B8%83%E7%89%9B%E4%BA%91%E5%AD%98%E5%82%A8/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-10-14T10:01:35.526Z">2020-10-14</time></p><p class="title"><a href="/2020/10/14/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82TCP-IP%E5%92%8CHTTP%E3%80%81HTTPS/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-10-14T10:01:31.281Z">2020-10-14</time></p><p class="title"><a href="/2020/10/14/%E8%BF%98%E5%9C%A8%E5%AD%A6JVM%EF%BC%9F%E6%88%91%E9%83%BD%E5%B8%AE%E4%BD%A0%E6%80%BB%E7%BB%93%E5%A5%BD%E4%BA%86%EF%BC%88%E9%99%84%E8%84%91%E5%9B%BE%EF%BC%89/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-10-14T10:01:28.566Z">2020-10-14</time></p><p class="title"><a href="/2020/10/14/%E5%88%AB%E5%86%8D%E9%97%AE%E6%88%91Redis%E5%86%85%E5%AD%98%E6%BB%A1%E4%BA%86%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E%E4%BA%86/"> </a></p></div></article></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/10/"><span class="level-start"><span class="level-item">October 2020</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><!--!--></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/logo.png" alt="非科班的科班" height="28"></a><p class="size-small"><span>&copy; 2020 黎杜</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a> &amp; <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">Amazing</a> <br><span>© <a href="http://www.beian.miit.gov.cn/" target="_blank">川ICP备88888888号-8（测试）</a><br></span><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️Site from <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> has existed <strong>" + dnum + "</strong> d <strong>" + hnum + "</strong> h <strong>" + mnum + "</strong> m <strong>" + snum + "</strong> s！❤️";
        }var now = new Date();setInterval("createTime('2018/11/11 00:00:00')", 250,"");</script><br></span><div class="size-small"><span>❤️Thx <strong><span id="busuanzi_value_site_uv">99+</span></strong> users <strong><span id="busuanzi_value_site_pv">99+</span></strong> visited！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/removeif/hexo-theme-amazing"><i class="fab fa-github"></i></a></p></div><div class="sideMusic"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="/js/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js style="width: auto;height: 2000px;" server="netease" type="playlist" id="2364053447" theme="#2980b9" loop="all" autoplay="false" order="list" storageName="aplayer-setting" lrctype="0" list-max-height="400px" fixed="true"></meting-js></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'folded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('46a9f3481b46ea0129d8','79c7c9cb847e141757d7864453bcbf89f0655b24','黎杜','blog_comment',false);})</script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(true){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('46a9f3481b46ea0129d8','79c7c9cb847e141757d7864453bcbf89f0655b24','黎杜','blog_comment',false);});
            }
            if(false){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>